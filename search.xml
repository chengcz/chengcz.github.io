<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>从 p.HGVS 到基因组变异位置</title>
      <link href="/2018/201807_transvar/"/>
      <url>/2018/201807_transvar/</url>
      <content type="html"><![CDATA[<h3 id="transcvar-web-版"><a href="#transcvar-web-版" class="headerlink" title="transcvar web 版"></a>transcvar web 版</h3><p><img src="./images/2018/transvar_web.png" alt=""></p><h3 id="transcvar-本地化"><a href="#transcvar-本地化" class="headerlink" title="transcvar 本地化"></a>transcvar 本地化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> https://github.com/zwdzwd/transvar</span><br><span class="line">pip search transvar</span><br><span class="line">pip install transvar --user</span><br><span class="line"></span><br><span class="line">transvar config --download_ref --refversion hg19</span><br><span class="line">transvar config --download_anno --refversion hg19</span><br></pre></td></tr></table></figure><p><img src="./images/2018/transvar.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">head HGVS_cds</span><br><span class="line"><span class="meta">#</span> MLH1:c.100G&gt;A</span><br><span class="line"><span class="meta">#</span> MLH1:c.790+1G&gt;A</span><br><span class="line"><span class="meta">#</span> VHL:c.1_17del17</span><br><span class="line"><span class="meta">#</span> VHL:c.136G&gt;T</span><br><span class="line"></span><br><span class="line">transvar canno --refversion hg19 --refseq -l HGVS_cds --oneline &gt;HGVS_cds.transvar.txt</span><br><span class="line"></span><br><span class="line">head HGVS_cds.transvar.txt</span><br><span class="line"><span class="meta">#</span> inputtranscriptgenestrandcoordinates(gDNA/cDNA/protein)regioninfo</span><br><span class="line"><span class="meta">#</span> MLH1:c.100G&gt;ANM_001167618 (protein_coding)MLH1+chr3:g.37059029G&gt;A/c.100G&gt;A/p.A34Tinside_[cds_in_exon_10]CSQN=Missense;reference_codon=GCC;alternative_codon=ACC;dbxref=GeneID:4292,HGNC:7127,HPRD:00390,MIM:120436;aliases=NP_001161090;source=RefSeq</span><br><span class="line"><span class="meta">#</span> MLH1:c.790+1G&gt;ANM_001258271 (protein_coding)MLH1+chr3:g.37056036G&gt;A/c.790+1G&gt;A/.inside_[intron_between_exon_9_and_10]CSQN=IntronicSNV;dbxref=GeneID:4292,HGNC:7127,HPRD:00390,MIM:120436;aliases=NP_001245200;source=RefSeq</span><br><span class="line"><span class="meta">#</span> VHL:c.1_17del17NM_198156 (protein_coding)VHL+chr3:g.10183532_10183548del17/c.1_17del17/.inside_[cds_in_exon_1]CSQN=CdsStartDeletion;left_align_gDNA=g.10183529_10183545del17;unaligned_gDNA=g.10183532_10183548del17;left_align_cDNA=c.1-3_14del17;unalign_cDNA=c.1_17del17;cds_start_at_chr3:10183532_lost;dbxref=GeneID:7428,HGNC:12687,HPRD:01905,MIM:608537;aliases=NP_937799;source=RefSeq</span><br></pre></td></tr></table></figure><p>类似的也可以从 c.HGVS、g.HGVS 开始获得完整注释</p><h3 id="本地化数据库配置"><a href="#本地化数据库配置" class="headerlink" title="本地化数据库配置"></a>本地化数据库配置</h3><p>软件提供数据库路径为：<a href="http://transvar.info/transvar_user/annotations/" target="_blank" rel="noopener">http://transvar.info/transvar_user/annotations/</a>，本地数据库配置详细如下：</p><p><img src="./images/2018/transvar_config.png" alt=""></p><p><img src="./images/2018/transvar_config2.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hgvs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lncRNA 根据染色体位置进行分类</title>
      <link href="/2018/201807_lnc_classification/"/>
      <url>/2018/201807_lnc_classification/</url>
      <content type="html"><![CDATA[<p>1/1/2018 </p><hr><p>根据与基因的相对位置，lncRNA可以分为<strong>Intergenic LncRNAs(lincRNA)</strong>, <strong>Bidirectional LncRNAs</strong>, <strong>Intronic LncRNAs</strong>, <strong>Antisense LncRNAs</strong>, <strong>Sense-overlapping LncRNAs</strong>五类，每类详细定义规则如下：</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>ref: <a href="https://www.arraystar.com/reviews/v30-lncrna-classification/" target="_blank" rel="noopener">https://www.arraystar.com/reviews/v30-lncrna-classification/</a></p><ol><li><p>Intergenic LncRNAs</p><p><img src="/2018/201807_lnc_classification/./images/2018/lnc_intergenic.jpeg" alt=""></p><p>Intergenic LncRNAs are long non-coding RNAs which locate between annotated protein-coding genes and are at least 1 kb away from the nearest protein-coding genes. They are named according to their 3-protein-coding genes nearby. Gene expression patterns have implicated these LincRNAs in diverse biological processes, including cell-cycle regulation, immune surveillance and embryonic stem cell pluripotency. LincRNAs collaborate with chromatin modifying protein (PRC2, CoREST and SCMX) to regulate gene expression at specific loci.</p></li><li><p>Bidirectional LncRNAs</p><p><img src="/2018/201807_lnc_classification/./images/2018/lnc_bidirectional.jpeg" alt=""></p><p>A Bidirectional LncRNA is oriented head to head with a protein-coding gene within 1kb. A Bidirectional LncRNA transcript exhibits a similar expression pattern to its protein-coding counterpart which suggests that they may be subject to share regulatory pressures. However, the discordant expression relationships between bidirectional LncRNAs and protein coding gene pairs have also been found, challenging the assertion that LncRNA transcription occurs solely to “open” chromatin to promote the expression of neighboring coding genes.</p></li><li><p>Intronic LncRNAs</p><p><img src="/2018/201807_lnc_classification/./images/2018/lnc_intronic.jpeg" alt=""></p><p>Intronic LncRNAs are RNA molecules that overlap with the intron of annotated coding genes in either sense or antisense orientation. Most of the Intronic LncRNAs have the same tissue expression patterns as the corresponding coding genes, and may stabilize protein-coding transcripts or regulate their alternative splicing.</p></li><li><p>Antisense LncRNAs</p><p><img src="/2018/201807_lnc_classification/./images/2018/lnc_antisense.jpeg" alt=""></p><p>Antisense LncRNAs are RNA molecules that are transcribed from the antisense strand and overlap in part with well-defined spliced sense or intronless sense RNAs. Antisense-overlapping LncRNAs have a tendency to undergo fewer splicing events and typically show lower abundance than sense transcripts. The basal expression levels of antisense-overlapping LncRNAs and sense mRNAs in different tissues and cell lines can be either positively or negatively regulated. Antisense-overlapping LncRNAs are frequently functional and use diverse transcriptional and post-transcriptional gene regulatory mechanisms to carry out a wide variety of biological roles.</p></li><li><p>Sense-overlapping LncRNAs</p><p><img src="/2018/201807_lnc_classification/./images/2018/lnc_sense.jpeg" alt=""></p><p>These LncRNAs can be considered transcript variants of protein-coding mRNAs, as they overlap with a known annotated gene on the same genomic strand. The majority of these LncRNAs lack substantial open reading frames (ORFs) for protein translation, while others contain an open reading frame that shares the same start codon as a protein-coding transcript for that gene, but unlikely encode a protein for several reasons, including non-sense mediated decay (NMD) issues that limits the translation of mRNAs with premature termination stop codons and trigger NMD-mediated destruction of the mRNA, or an upstream alternative open reading frame which inhibits the translation of the predicted ORF.</p></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> step0 prepare</span><br><span class="line">awk -F "\t" 'BEGIN&#123;OFS="\t"&#125;&#123;if ($3=="transcript") &#123;print $1,$4,$5,$9,$7&#125;&#125;' lnc.gtf | sed -e 's/gene_id.*transcript_id "//g' -e 's/".*\t/\t.\t/g' &gt;lnc.transcript.bed</span><br><span class="line">awk -F "\t" 'BEGIN&#123;OFS="\t"&#125;&#123;if ($3=="transcript") &#123;print $1,$4,$5,$9,$7&#125;&#125;' mRNA.gtf | sed -e 's/gene_id.*transcript_id "//g' -e 's/".*\t/\t.\t/g' &gt;mRNA.transcript.bed</span><br><span class="line">awk -F "\t" 'BEGIN&#123;OFS="\t"&#125;&#123;if ($3=="exon") &#123;print $1,$4,$5,$9,$7&#125;&#125;' mRNA.gtf | sed -e 's/gene_id.*transcript_id "//g' -e 's/".*\t/\t.\t/g' &gt;mRNA.exon.bed</span><br><span class="line"></span><br><span class="line">head mRNA.transcript.bed</span><br><span class="line"><span class="meta">#</span> chr16541971585ENST00000641515.+</span><br><span class="line"><span class="meta">#</span> chr16905570108ENST00000335137.+</span><br><span class="line"><span class="meta">#</span> chr1450703451697ENST00000426406.-</span><br><span class="line"><span class="meta">#</span> chr1685679686673ENST00000332831.-</span><br><span class="line"><span class="meta">#</span> chr1923928939291ENST00000420190.+</span><br><span class="line"><span class="meta">#</span> chr1925150935793ENST00000437963.+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> step1 获得 Intergenic lncRNA</span><br><span class="line"><span class="meta">#</span> -v 取反，获得不和任何 coding-protein 基因（包括基因上下游 1000 bp范围）重合的 lncRNA</span><br><span class="line">bedtools window -a lnc.transcript.bed -b mRNA.transcript.bed -v &gt;lnc.Intergenic.bed</span><br><span class="line"><span class="meta">#</span>############## lnc.Intergenic.bed ###############</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> step2 基因 1000 bp 区间内的 lncRNA</span><br><span class="line"><span class="meta">#</span> 获得和 coding-protein 有重叠的 lncRNA ，lnc_gene.bed</span><br><span class="line">bedtools intersect -a lnc.transcript.bed -b mRNA.transcript.bed -wa | sort -u &gt; lnc_gene.bed</span><br><span class="line"><span class="meta">#</span> 获得 coding-protein 基因上下游 1000 bp 范围内的 lnc ，lnc_gene_1k.bed</span><br><span class="line">python -c 'with open("lnc.transcript.bed") as a, open("lnc_gene.bed") as m, open("lnc.Intergenic.bed") as i, open("lnc_gene_1k.bed", "w") as k1: k1.write("".join(set(a.readlines())-set(m.readlines())-set(i.readlines())))'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> step2b 根据转录方向进行分类</span><br><span class="line">bedtools window -a lnc_gene_1k.bed -b mRNA.transcript.bed -u -Sm | sort -u &gt;lnc.Bidirectional.bed</span><br><span class="line"><span class="meta">#</span>############## lnc.Bidirectional.bed ###############</span><br><span class="line">bedtools window -a lnc_gene_1k.bed -b mRNA.transcript.bed -u -sm | sort -u &gt;lnc.Enhancer.bed</span><br><span class="line"><span class="meta">#</span>############## lnc.Enhancer.bed ###############</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> step3 </span><br><span class="line"><span class="meta">#</span> 和 coding-protein 重叠，不和外显子重叠，得到内含子区域的lnc</span><br><span class="line">bedtools intersect -a lnc_gene.bed -b mRNA.exon.bed -v &gt; lnc.Intronic.bed</span><br><span class="line"><span class="meta">#</span>############## lnc.Intronic.bed ###############</span><br><span class="line"><span class="meta">#</span> 取相同链的 lnc</span><br><span class="line">bedtools intersect -a lnc_gene.bed -b mRNA.exon.bed -wa -s | sort -u &gt; lnc.Sense.bed</span><br><span class="line"><span class="meta">#</span>############## lnc.Sense.bed ###############</span><br><span class="line"><span class="meta">#</span> 取反向链的 lnc</span><br><span class="line">bedtools intersect -a lnc_gene.bed -b mRNA.exon.bed -wa -S | sort -u &gt; lnc.Antisense.bed</span><br><span class="line"><span class="meta">#</span>############## lnc.Antisense.bed ###############</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lnc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>家族基因分析的一般套路</title>
      <link href="/2018/201807_FamilyGene/"/>
      <url>/2018/201807_FamilyGene/</url>
      <content type="html"><![CDATA[<p>7/2016 </p><hr><ol><li><p>分析前准备</p><p>分析前准备主要是两点，找文章，找序列。</p><ul><li>找文章，该家族基因是否在研究物种或其他物种中报告，都进行了什么分析和试验；</li><li>找序列，获取该家族代表性序列进行后续分析</li></ul></li><li><p>家族基因成员鉴定</p><p>主要 blast 和 hmmer 两种方式，一般讲来使用两个方式的并集，然后根据基因特征再一步确认过滤</p><ul><li>blast</li><li>hmmer</li></ul></li><li><p>家族基因特征描述</p><ul><li>染色体分布</li><li>基因结构</li><li>motif分析</li><li>启动子序列分析</li></ul></li><li><p>多物种进化关系分析</p><ul><li>构建分子进化树</li><li>Ka/Ks计算等等</li></ul></li><li><p>基因分类命名</p><p>一般根据进化关系、或者分析特征进行分类，然后染色体顺序命名</p></li><li><p>基因表达分析</p><ul><li>多组织材料表达分析</li><li>不同处理样品表达分析</li><li>共表达分析</li></ul></li><li><p>候选基因表达、功能验证</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[FamilyGene.seq] -- blast --&gt; B[FamilyGene.list]</span><br><span class="line">A[FamilyGene.hmm] -- hmmer --&gt; B[FamilyGene.list]</span><br><span class="line">B[FamilyGene.list] --&gt; C[FeatureAnalysis]</span><br><span class="line">C[FeatureAnalysis] --&gt; Ca[染色体分布]</span><br><span class="line">C[FeatureAnalysis] --&gt; Cb[基因结构]</span><br><span class="line">C[FeatureAnalysis] --&gt; Cc[motif分析]</span><br><span class="line">C[FeatureAnalysis] --&gt; Cd[promotor seq analysis]</span><br><span class="line">B[FamilyGene.list] --&gt; D[phylogenetics]</span><br><span class="line">B[FamilyGene.list] --&gt; E[Group,Name]</span><br><span class="line">B[FamilyGene.list] --&gt; F[Expression]</span><br><span class="line">F[Expression] --&gt; G[表达, 功能验证]</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>identification of A-to-I RNA Editing</title>
      <link href="/2018/201807_RNAedit/"/>
      <url>/2018/201807_RNAedit/</url>
      <content type="html"><![CDATA[<ol><li><p>Quality Contorl of Fastq</p></li><li><p>Alignment to Reference Genome</p><p>Recommended use STAR-2pass to mapping reads to genome</p></li><li><p>Pre-process of Bam File</p><p>remove multi aglin, duplicate reads, splitN, and so on</p><p>Detailed operation can refer: <a href="https://software.broadinstitute.org/gatk/documentation/article.php?id=3891" target="_blank" rel="noopener">https://software.broadinstitute.org/gatk/documentation/article.php?id=3891</a></p></li><li><p>use GATK to call candidate site </p></li><li><p>Basic Variant filtering(optional)</p></li><li><p>Identification of editing sites</p><ul><li>Select single nucleotide variants(SNV) from all variant results , use snpEff to annot SNV</li><li>Select A&gt;T changes in the gene interval, <strong>depending on the direction of gene transcription</strong></li><li>Remove sites that appear in <a href="https://cancer.sanger.ac.uk/cosmic" target="_blank" rel="noopener">Cosmic</a>, <a href="https://www.ncbi.nlm.nih.gov/snp" target="_blank" rel="noopener">dbSNP</a>,  TCGA somatic mutations database</li><li>Remove sites which the editing level  is 1.0 in all sample</li><li>At least 10 reads in at least 1 sample</li><li>RNA editing sites is exists at least 2 sample</li></ul></li></ol><h3 id="ref："><a href="#ref：" class="headerlink" title="ref："></a>ref：</h3><ul><li>The Genomic Landscape and Clinical Relevance of A-to-I RNA Editing in Human Cancers </li><li>Dynamic regulation of RNA editing in human brain development and disease </li><li>A disrupted RNA editing balance mediated by ADARs (Adenosine DeAminases that act on RNA) in human hepatocellular carcinoma </li><li>ADAR1 promotes malignant progenitor reprogramming in chronic myeloid leukemia </li><li>Genome-wide analysis of A-to-I RNA editing by single-molecule sequencing in Drosophila </li></ul>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RNAediting </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>转:16S基本分析点</title>
      <link href="/2018/201807_16S/"/>
      <url>/2018/201807_16S/</url>
      <content type="html"><![CDATA[<p>8/23/2016 8:35 PM </p><hr><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="为什么选择16S测序？"><a href="#为什么选择16S测序？" class="headerlink" title="为什么选择16S测序？"></a>为什么选择16S测序？</h3><p>细菌中唯一的细胞器是核糖体，它的沉降系数是70S，由50S的大亚基和30S的小亚基组成，其中rRNA按沉降系数可分为5S、16S和23S三种，5S和23S rRNA在核糖体大亚基中，16S rRNA在核糖体小亚基中。5S rRNA的序列长度最长达400nt，信息量少；23S rRNA的序列长度长达2900nt，序列太长，测序通量、深度等要求高；而16S rRNA序列长度适中，约为1542nt。<br>沉降系数：离心法时，大分子沉降速度的量度，等于每单位离心场的速度。沉降系数10-13秒称为一个Svedberg单位，简写S，量纲为秒。</p><h3 id="16S测序区域如何选择？"><a href="#16S测序区域如何选择？" class="headerlink" title="16S测序区域如何选择？"></a>16S测序区域如何选择？</h3><p>16S rDNA是编码16S rRNA的DNA序列，存在于所有的细菌和古菌的基因组中，一般由9个保守区和9个可变区组成，保守区在细菌间无显著差异，可用于构建所有生命的统一进化树，而可变区在不同细菌中存在一定的差异，可将菌群鉴定精细到分类学上属，甚至种的级别。</p><h3 id="16S-rDNA测序区域与哪些因素有关？"><a href="#16S-rDNA测序区域与哪些因素有关？" class="headerlink" title="16S rDNA测序区域与哪些因素有关？"></a>16S rDNA测序区域与哪些因素有关？</h3><ul><li><a href="http://www.ncbi.nlm.nih.gov/pubmed/19816594" target="_blank" rel="noopener">引物序列</a>， 16S目的片段的引物是基于保守区的序列设计的，但是由于保守序列的碱基存在多态性，可能会忽略一部分微生物，因此要选用覆盖率高的引物进行目的片段的扩增；</li><li>测序平台， Illumina MiSeq/HiSeq测序平台的架构决定其短读长，它的读长最长为2*300pb，限制16S只能进行单V区、双V区或者三V区的测定；</li><li>目的区域中已知序列的多少， 扩增的目的片段与数据库中已知的片段进行比对，如果数据库中该区域已知片段很少，很不全面，导致测得的序列比对不上，微生物的多样性随之降低；</li><li><a href="https://www.researchgate.net/publication/260598361_Evaluation_of_the_RDP_Classifier_Accuracy_Using_16S_rRNA_Gene_Variable_Regions" target="_blank" rel="noopener">不同区域中鉴定物种的准确性</a>， 不同区域的物种比对到RDP数据库时，鉴定物种的准确性也是测序区域选择的约束条件。单个区域的检测发现，V2区和V4区在各个水平上的精确度最高，V5、V6、V7、V8区在门、纲水平上的精确度也较高，与V2区和V4区相似。</li></ul><h3 id="OTU是什么"><a href="#OTU是什么" class="headerlink" title="OTU是什么"></a>OTU是什么</h3><p>OTU（operational taxonomic units），即操作分类单元。通过一定的距离度量方法计算两两不同序列之间的距离度量或相似性，继而设置特定的分类阈值，获得同一阈值下的距离矩阵，进行聚类操作，形成不同的分类单元。</p><h3 id="OTU在16S测序中有何用"><a href="#OTU在16S测序中有何用" class="headerlink" title="OTU在16S测序中有何用"></a>OTU在16S测序中有何用</h3><p>高通量测序得到的16S序列有成千上万条，如果对每条序列都进行物种注释的话，工作量大、耗时长，而且16S扩增、测序等过程中出现的错误会降低结果的准确性。在16S分析中引入OTU，首先对相似性序列进行聚类，分成数量较少的分类单元，基于分类单元进行物种注释。这不仅简化工作量，提高分析效率，而且OTU在聚类过程中会去除一些测序错误的序列，提高分析的准确性。</p><h3 id="OTU如何聚类"><a href="#OTU如何聚类" class="headerlink" title="OTU如何聚类"></a>OTU如何聚类</h3><p>OTU聚类的方法多种多样，如Uclust、cd-hit、BLAST、mothur、usearch和 prefix/suffix，这些聚类方法均可以在QIIME软件中实施。不同聚类方法基于不同的算法，得到的聚类结果虽然不同，但是大体的聚类流程都是一致的，挑选非重复序列，与16S数据库比对，去除嵌合体序列，序列之间距离计算，97%相似OTU聚类。</p><blockquote><p>嵌合体序列是RCR扩增时，两条不同的序列产生杂交、扩增的序列</p></blockquote><h3 id="OTU跟物种的关系"><a href="#OTU跟物种的关系" class="headerlink" title="OTU跟物种的关系"></a>OTU跟物种的关系</h3><p>OTU聚类后，挑选出每个OTU中的代表序列，与RDP、Sliva或GreenGene等数据库进行比对，进行物种注释。OTU和物种是映射关系，它们一一对应或多对一关系</p><hr><h2 id="Alpha多样性"><a href="#Alpha多样性" class="headerlink" title="Alpha多样性"></a>Alpha多样性</h2><p><strong>Alpha多样性</strong>：指一个区域或生态系统内的多样性，用来描述单个样品的物种多样性；Alpha多样性指数主要用来表征三方面信息：物种丰度、物种多样性和测序深度。</p><ol><li>物种丰度</li></ol><ul><li><strong>observed_species指数</strong>：表示实际观测到的OTU数量；</li><li><strong>chao1指数</strong>：评估样品中所含OTU的总数。其公式为：<br><img src="http://i.imgur.com/9PBAXVy.png" alt=""><blockquote><p>Schao1：估计的OTU数量；<br>Sobs：实际观察到的OTU数量；<br>n1：只含一条序列的OTU的数量；<br>n2：含两条序列的OTU的数量。</p></blockquote></li></ul><ol start="2"><li>物种多样性</li></ol><ul><li><p><strong>Shannon指数</strong>：包含着种数和各种间个体分配的均匀性两个部分。如果每一个体都属于不同的种，多样性指数就最大；如果每一个体都属于同一种，则其多样性指数就最小。用来估算微生物群落的多样性，shannon值越大，物种多样性越高。其计算公式：<br><img src="http://i.imgur.com/VGZejz7.png" alt=""></p><blockquote><p>Sobs：实际观察到的OTU数量；<br>ni：第i条OTU的序列数量；<br>N：所有的序列数。</p></blockquote></li><li><p><strong>Simpson指数</strong>：随机抽取的两个个体属于不同种的概率，Simpson指数越大，物种多样性越高。其计算公式：<br><img src="http://i.imgur.com/83QuQEB.png" alt=""></p><blockquote><p>Sobs：实际观察到的OTU数量；<br>ni：第i个OTU的序列数量；<br>N：所有的序列数。</p></blockquote></li></ul><p>3 . 测序深度</p><ul><li><strong>Coverage</strong>：反应测序深度，goods_coverage 指数越接近于1，说明测序深度已经基本覆盖到样品中所有的物种。其计算公式：<br><img src="http://i.imgur.com/zhXuYZM.png" alt=""><blockquote><p>Cdepth：goods_coverage指数表示测序深度；<br>n1：只有含一条序列的OTU数目；<br>N：为抽样中出现的总的序列数。</p></blockquote></li></ul><h3 id="如何展现Alpha多样性指数"><a href="#如何展现Alpha多样性指数" class="headerlink" title="如何展现Alpha多样性指数"></a>如何展现Alpha多样性指数</h3><p>Alpha多样性指数数值可以以表格的形式展现，还可以以图表的形式展现。随着抽取的reads条数的增加，曲线逐渐趋平，表明测序量是足够的，可以覆盖样品中的大部分微生物；如果曲线呈现上升趋势，则需要增加测序量，保障测序结果的代表性。简单来说，其实Alpha多样性指数就是衡量测序量是否足够的一个标准。它们大都长成这个样子。<br><img src="http://i.imgur.com/wSaLsXJ.png" alt=""></p><hr><h2 id="Beta多样性"><a href="#Beta多样性" class="headerlink" title="Beta多样性"></a>Beta多样性</h2><p><strong>Beta多样性</strong>：指不同生态系统之间的多样性比较，用来比较组间样品在物种多样性上存在的差异。Beta多样性是基于不同样品序列间的进化关系及丰度信息来计算样品间距离，用来描述不同样品间的相似性和差异性。<br>样本间距离是指样本之间的相似程度，可以通过数学方法估算。如前所述，样本间越相似，距离数值越小。计算微生物群体样本间距离的方法有多种，例如，Jaccard、Bray-Curtis、Unifrac等。这些距离算法主要分为两大类别：<strong>OTU间是否关联</strong>；<strong>OTU是否加权(表)</strong></p><table><thead><tr><th>\</th><th>基于独立OUT</th><th>基于系统发生数</th></tr></thead><tbody><tr><td>加权</td><td>Bray-Curtis</td><td>Weighted Unifrac</td></tr><tr><td>非加权</td><td>Jaccard</td><td>Unweighted Unifrac</td></tr></tbody></table><ul><li><p><strong>基于独立OTU vs 基于系统发生树</strong><br>二代测序当中，我们对16s rDNA某个区域进行测序后，会根据序列的相似度定义OTU。这个时候，基于独立OTU的计算方式认为OTU之间不存在进化上的联系，每个OTU间的关系平等。而基于系统发生树计算的方法，会根据16s的序列信息对OTU进行进化树分类，因此不同OTU之间的距离实际上有“远近”之分。</p></li><li><p><strong>加权 vs 非加权</strong><br>利用非加权的计算方法，主要考虑的是物种的有无，即如果两个群体的物种类型都一致，表示两个群体的β多样性最小。而加权方法，则同时考虑物种有无和物种丰度两个问题。如果A群体由3个物种a和2个物种b组成，B群体由2个物种a和3个物种b组成，则通过非加权方法计算，因为A群体与B群体的物种组成完全一致，都只由物种a和b组成，因此它们之间的β多样性为0。但通过加权方法计算，虽然A与B群体的组成一致，但物种a和b的数目却不同，因此两个群体的β多样性则并非一致。</p></li></ul><p>在宏基因组和16s测序的分析中，使用最多的距离算法主要有Bray-Curtis和Weighted 及Unweighted Unifrac。因此，下面我们就这几种常用的微生物多样性算法的特点和应用范围进行简单比较。</p><ul><li><p><strong>Bray-Curtis距离 vs Unifrac距离</strong><br>Bray-Curtis距离和Unifrac距离的主要区别在于计算β值的时候是否考虑OTU的进化关系。根据表2，显然，只有后者是有考虑。这会影响到它们的：<strong>数值表述意义不同</strong>：虽然两种方法的数值都是在0-1之间，但具体所表示的生物学意义却不一样。在Bray-Curtis算法中，0表示两个微生物群落的OTU结构（包括组成和丰度）完全一致；而在Unifrac中，0更侧重于表示两个群落的进化分类完全一致；<strong>实际应用的合理性</strong>：在实际微生物研究中，如果样本间物种的近源程度较高（温和处理样本与对照样本，生境相似的不同样本等），利用Bray-Curtis这种把OTU都同等对待的方法，更有利于发现样本间的差异。而Unifrac则更适合用于展示此类样本的重复性。</p></li><li><p><strong>Weighted Unifrac距离 vs Unweighted Unifrac距离</strong><br>Unifrac除了具有考虑OTU之间的进化关系的特点之外，根据有没有考虑OTU丰度的区别，Unifrac分析可以分为加权（WeightedUunifrac）和非加权（Unweighted Unifrac）两种方法。它们的不同在于：<strong>数值表述意义</strong>：Unweighted UniFrac只考虑了物种有无的变化，因此结果中，0表示两个微生物群落间OTU的种类一致。而Weighted UniFrac则同时考虑物种有无和物种丰度的变化，结果中的0则表示群落间OTU的种类和数量都一致。<strong>实际应用的合理性</strong>：在环境样本的检测中，由于影响因素复杂，群落间物种的组成差异更为剧烈，因此往往采用非加权方法进行分析。但如果要研究对照与实验处理组之间的关系，例如研究短期青霉素处理后，人肠道的菌落变化情况，由于处理后群落的组成一般不会发生大改变，但群落的丰度可能会发生大变化，因此更适合用加权方法去计算。</p></li></ul><h3 id="多样性分析方法"><a href="#多样性分析方法" class="headerlink" title="多样性分析方法"></a>多样性分析方法</h3><ol><li><p>Unifrac分析<br>基于系统进化，在 OTU水平上反应不同组间微生物群落结构的差异。若两个微生物群落完全相同，它们是没有各自独立的进化过程，UniFrac的值为0；UniFrac值越大，说明不同微生物群落在进化过程中变异越大，两个微生物群落在进化树中完全分开，则它们是两个完全独立的进化过程，UniFrac值最大，为1。<br><img src="http://i.imgur.com/2MsWX3u.jpg" alt=""></p><blockquote><p>图A和图B是Unifrac的两种展现形式，样品越靠近说明两个样品的组成越相似。</p></blockquote></li><li><p>PCoA分析<br>PCoA（principal coordinate analysis）主坐标分析，基于降维的方法，在尽可能保留原始信息的情况下，找出前两种影响分组的信息，研究其对样品分组的贡献率，将样品的相似性或差异性可视化，这两个坐标轴是没有任何实际意义的。分析结果展示如下，如果两个样品间距离较近，则表示这两个样品的物种组成比较相近。<br><img src="http://i.imgur.com/W4N2aEV.png" alt=""></p><blockquote><p>横坐标即第一主坐标，表示对样品分开的贡献率是60.91%；纵坐标即第二主坐标，表示对样品分开的贡献率是14.06%。箱线图的添加是本图的一个特色，直观地展现样品在第一主坐标和第二主坐标的分布情况。</p></blockquote></li><li><p>NMDS分析<br>NMDS与PCoA分析的意义一样，都 是用来展示样品间差异和相似的方法，如果两个样品距离较近，则表示这两个样品的物种组成比较相近。不同之处是两种展现形式是基于不同的算法。<br><img src="http://i.imgur.com/ZVl5Pwq.png" alt=""></p><blockquote><p>横纵坐标是基于进化或者数量距离矩阵的数值在二维表中成图，不同颜色代表不同分组，点代表样品，点与点之间的距离表示差异程度。</p></blockquote></li><li><p>Anosim分析<br>相似性分析Anosim分析是一种非参数检验，用来检验组间(两组或多组)的差异是否显著大于组内差异，从而判断分组是否有意义。首先利用Bray-Curtis算法计算两两样品间的距离，然后将所有距离从小到大进行排序。<br><img src="http://i.imgur.com/k5hcG1f.png" alt=""></p><blockquote><p>横坐标表示所有样品(Between)以及每个分组(A、B)，纵坐标表示unifrac距离的秩。Between组比其它每个分组的秩较高时，则表明组间差异大于组内差异。R介于(-1，1)之间，R大于0，说明组间差异显著；R小于0，说明组内差异大于组间差异，统计分析的可信度用P表示，P&lt; 0.05表示统计具有显著性。</p></blockquote></li><li><p>UPGMA层次聚类<br>假设在进化过程中所有核苷酸(氨基酸)的变异率相同，基于群落组成和结构的算法计算样本间的距离，根据β多样性距离矩阵进行层次聚类分析，最后通过UPGMA构建系统进化树。此树可以直观的反应样本间进化的差异。<br><img src="http://i.imgur.com/WJ9YvIq.png" alt=""></p><blockquote><p>UPGMA层次聚类分析。树枝不同颜色代表不同的分组。</p></blockquote></li></ol><h3 id="Beta多样性分析还有什么要点？"><a href="#Beta多样性分析还有什么要点？" class="headerlink" title="Beta多样性分析还有什么要点？"></a>Beta多样性分析还有什么要点？</h3><p>上面的Unifra、PCoA、NMDS、Anosim和UPGMA分析均可做考虑物种丰度（加权，Weight）和不考虑物种丰度（非加权，Unweight）的两种展现形式，可以根据你的研究目的选择合适的计算方法。</p><hr>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>matplotlib 画图的 Qt 问题</title>
      <link href="/2018/201807_matplotlib/"/>
      <url>/2018/201807_matplotlib/</url>
      <content type="html"><![CDATA[<ol><li><p>This application failed to start because it could not find or load the Qt platform plugin “xcb” in “”.</p><p><img src="/2018/201807_matplotlib/./images/2018/Snipaste_180702_14-11-26.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export QT_PLUGIN_PATH="/data/software/anaconda2/plugins/"</span><br></pre></td></tr></table></figure></li><li><p>QXcbConnection: Could not connect to display</p><p><img src="/2018/201807_matplotlib/./images/2018/Snipaste_180702_14-11-09.png" alt=""></p><p>方法一：</p><ul><li>设置环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export QT_QPA_PLATFORM='offscreen'</span><br></pre></td></tr></table></figure><p>方法二：</p><ul><li>python 画图脚本添加下面两行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">'Agg'</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>canonical transcripts of Human protein coding gene</title>
      <link href="/2018/201806_HumanGene/"/>
      <url>/2018/201806_HumanGene/</url>
      <content type="html"><![CDATA[<p>我们使用 <a href="https://chengcz.github.io/2018/201805_snpEff/">snpEff</a>, <a href="https://chengcz.github.io/2018/201806_ANNOVAR/">annovar</a> 对得到的变异集注释，总会得到多个转录本注释结果，而只需要按照 HGVS 规范报告一个经典转录本(canonical transcripts) 对应注释结果，这时候就需要知道每个基因对应的经典转录本。</p><p>一般情况下，我们使用<strong>基因对应的最长转录本代表该基因</strong>，具体操作上，首先从 <a href="https://chengcz.github.io/2018/201805_HGVS/">HGNC</a> 下载经过确认的基因对应经典转录本信息，其中不确定基因再使用最长转录本代表。</p><ol><li><p>HGNC 下载编码蛋白基因对应转录本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> wget -c ftp://ftp.ebi.ac.uk/pub/databases/genenames/new/tsv/locus_types/gene_with_protein_product.txt</span><br></pre></td></tr></table></figure><p>根据表格，很方便得到基因名字对应 hgnc_id, entrez_id, ensembl_gene_id, refseq_accession 等多数据库基因ID，使用 refseq_accession 进行 HGVS 表示，这里就只关注 refseq_accession ， 还是可以发现其中一些基因名并不能对应到唯一 refseq_accession，下面就需要我们进行第二步，结合 GFF 文件挑出经典转录本。</p></li><li><p>NCBI下载人类基因注释GFF文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> wget -c ftp://ftp.ncbi.nlm.nih.gov/refseq/H_sapiens/annotation/GRCh37_latest/refseq_identifiers/GRCh37_latest_genomic.gff.gz</span><br></pre></td></tr></table></figure><p>使用脚本将 gff 转换为表格样式，方便筛选每个基因对应最长转录本，具体操作参考如下，其中 <a href="https://github.com/chengcz/pyGTF" target="_blank" rel="noopener">pyGTF</a> 为用来解析 gff 文件。</p><p><img src="/2018/201806_HumanGene/./images/2018/gff2tab.png" alt=""></p><p>输出文件可以<a href="https://github.com/chengcz/BioResource/tree/master/HumanGene" target="_blank" rel="noopener">下载</a> , 其具体格式为：</p><p><img src="/2018/201806_HumanGene/./images/2018/gff_tab.png" alt=""></p><p>表头分别是：gene_id, gene_name, gene_type, transcript_id, transcript_name, transcript_type, transcript_length, chromosome, start, end, strand，根据 gene_name, transcript_name, transcript_length 三列排序，就可以很方便筛选出基因对应最长转录本。</p></li><li><p>脚本整合 HGNC 和 GFF 两部分结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">gene, length = &#123;&#125;, &#123;&#125;</span><br><span class="line">gff = pd.read_table(<span class="string">'hg37.geneinfo.txt'</span>, header=<span class="keyword">None</span>)</span><br><span class="line">gff = gff[(gff[<span class="number">2</span>]==<span class="string">'protein_coding'</span>) | (gff[<span class="number">5</span>]==<span class="string">'protein_coding'</span>)]</span><br><span class="line">nrow, ncol = gff.shape</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(nrow):</span><br><span class="line">    transcriptid = gff.iloc[index,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        transcriptid = transcriptid[:transcriptid.rindex(<span class="string">'.'</span>)]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    gene.setdefault(gff.iloc[index,<span class="number">1</span>], []).append(transcriptid)</span><br><span class="line">    length[transcriptid] = gff.iloc[index,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">hgnc = pd.read_table(<span class="string">'gene_with_protein_product.txt'</span>)</span><br><span class="line">hgnc[<span class="string">'symbol'</span>] = hgnc[<span class="string">'symbol'</span>].astype(str)</span><br><span class="line">hgnc[<span class="string">'refseq_accession'</span>] = hgnc[<span class="string">'refseq_accession'</span>].astype(str)</span><br><span class="line">nrow, ncol = hgnc.shape</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(nrow):</span><br><span class="line">    genename = hgnc.loc[index, <span class="string">'symbol'</span>]</span><br><span class="line">    refseq = hgnc.loc[index, <span class="string">'refseq_accession'</span>]</span><br><span class="line">    tmp = refseq.split(<span class="string">'|'</span>)</span><br><span class="line">    <span class="keyword">if</span> len(tmp) == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'&#123;&#125;\t&#123;&#125;\thgnc'</span>.format(genename, refseq))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> len(tmp) == <span class="number">0</span>:</span><br><span class="line">            tmp = gene[genename]</span><br><span class="line">        tmp = sorted(tmp, key=<span class="keyword">lambda</span> x: length.get(x, <span class="number">0</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">        print(<span class="string">'&#123;&#125;\t&#123;&#125;\tgff'</span>.format(genename, tmp[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p>结果整理文件可下载：<a href="https://github.com/chengcz/BioResource/tree/master/HumanGene/protein_coding_gene_canonical_transcripts.txt" target="_blank" rel="noopener">https://github.com/chengcz/BioResource/tree/master/HumanGene/protein_coding_gene_canonical_transcripts.txt</a></p></li></ol>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gtf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 python 正确读取不同编码方式文本</title>
      <link href="/2018/201806_python_decode/"/>
      <url>/2018/201806_python_decode/</url>
      <content type="html"><![CDATA[<p>通常情况下，都会默认输入文件以 utf-8 的方式进行编码，总会有几个奇葩输入文件存在，导入分析流程，啊额，编码问题运行终止，再来一遍呢还是再来一遍。</p><p>技术问题还是选择用技术手段解决好些，是吧，一个简单的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> open</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Read_File_Right_Encode</span><span class="params">(fp, encodelst=None)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># content = subprocess.check_output('iconv -f GBK -t utf-8 &#123;file&#125;')</span></span><br><span class="line">    <span class="keyword">with</span> open(fp, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        tmp = f.read()</span><br><span class="line">    <span class="keyword">if</span> encodelst <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    encodelst = [<span class="string">'gbk'</span>, <span class="string">'ascii'</span>, <span class="string">'utf-8'</span>]</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> x == len(encodelst):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Can\'t find right coding format of &#123;&#125; in decode list: &#123;&#125;'</span>.format(fp, <span class="string">', '</span>.join(encodelst)))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = tmp.decode(encodelst[x])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> content</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>NA12878 全外显子数据分析结果比较</title>
      <link href="/2018/201806_compare_vcf/"/>
      <url>/2018/201806_compare_vcf/</url>
      <content type="html"><![CDATA[<p>一直都比较有兴趣分析 human DNA 变异，参照 gatk 流程分析了 NA12878 的全外数据，正好有参考变异集，比较下分析准确性，也好参数调整优化之类，吧吧吧，下面就是一些详细步骤粘贴整理</p><h3 id="NA12878-vcf-处理"><a href="#NA12878-vcf-处理" class="headerlink" title="NA12878.vcf 处理"></a>NA12878.vcf 处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> wget -c ftp://ftp-trace.ncbi.nih.gov/giab/ftp/data/NA12878/Garvan_NA12878_HG001_HiSeq_Exome/project.NIST.hc.snps.indels.vcf</span><br><span class="line">hc_snp_indel=project.NIST.hc.snps.indels.vcf</span><br><span class="line"><span class="meta">#</span> wget -c ftp://ftp-trace.ncbi.nih.gov/giab/ftp/data/NA12878/Garvan_NA12878_HG001_HiSeq_Exome/nexterarapidcapture_expandedexome_targetedregions.bed</span><br><span class="line">intervals=nexterarapidcapture_expandedexome_targetedregions.bed</span><br><span class="line"></span><br><span class="line">java -jar GenomeAnalysisTK.jar \</span><br><span class="line">    -T SelectVariants \</span><br><span class="line">    -R $genome \</span><br><span class="line">    -V $hc_snp_indel \</span><br><span class="line">    -L $intervals \</span><br><span class="line">    -sn NIST7035 \</span><br><span class="line">    -select 'DP &gt; 5' \</span><br><span class="line">    --excludeNonVariants \</span><br><span class="line">    -o ref.NIST7035.hc.snps.indels.vcf.gz</span><br><span class="line"><span class="meta">#</span> 选择特定区间内 DP 大于5，样品 NIST7035 的变异位点</span><br></pre></td></tr></table></figure><h3 id="vcf-处理"><a href="#vcf-处理" class="headerlink" title="vcf 处理"></a>vcf 处理</h3><p>ref: <a href="https://software.broadinstitute.org/gatk/documentation/article.php?id=2806" target="_blank" rel="noopener">https://software.broadinstitute.org/gatk/documentation/article.php?id=2806</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> SNP</span><br><span class="line">java -jar GenomeAnalysisTK.jar \</span><br><span class="line">    -T SelectVariants \</span><br><span class="line">    -R $genome \</span><br><span class="line">    -L $intervals \</span><br><span class="line">    -selectType SNP \</span><br><span class="line">    -V  NIST7035.vcf.gz \</span><br><span class="line">    -o NIST7035.snp.vcf.gz</span><br><span class="line">java -jar GenomeAnalysisTK.jar \</span><br><span class="line">    -T VariantFiltration \</span><br><span class="line">    -R $genome \</span><br><span class="line">    --filterExpression "DP &lt; 5" --filterName "LowDepth"  \</span><br><span class="line">    --filterExpression "FS &gt; 60.0 || SOR &gt; 3.0" --filterName "StrandBias"  \</span><br><span class="line">    --filterExpression "QD &lt; 2.0  || MQ &lt; 40.0 || MQRankSum &lt; -12.5" \</span><br><span class="line">    --filterName "snp_Filter"  \</span><br><span class="line">    --filterExpression "ReadPosRankSum &lt; -8.0" --filterName "endOfRead"  \</span><br><span class="line">    -V  NIST7035.snp.vcf.gz \</span><br><span class="line">    -o  NIST7035.snp.filter.vcf.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Indel</span><br><span class="line">java -jar GenomeAnalysisTK.jar \</span><br><span class="line">    -T SelectVariants \</span><br><span class="line">    -R $genome \</span><br><span class="line">    -L $intervals \</span><br><span class="line">    -selectType INDEL \</span><br><span class="line">    -V  NIST7035.vcf.gz \</span><br><span class="line">    -o NIST7035.indel.vcf.gz</span><br><span class="line">java -jar GenomeAnalysisTK.jar \</span><br><span class="line">    -T VariantFiltration \</span><br><span class="line">    -R $genome \</span><br><span class="line">    --filterExpression "DP &lt; 5" --filterName "LowDepth"  \</span><br><span class="line">    --filterExpression "QD &lt; 2.0 || FS &gt; 200.0" \</span><br><span class="line">    --filterName "InDels_Filter" \</span><br><span class="line">    --filterExpression "ReadPosRankSum &lt; -20.0" --filterName "endOfRead" \</span><br><span class="line">    -V NIST7035.indel.vcf.gz \</span><br><span class="line">    -o NIST7035.indel.filter.vcf.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> MergeVcf</span><br><span class="line">java -jar picard.jar MergeVcfs \</span><br><span class="line">    I=NIST7035.indel.filter.vcf.gz \</span><br><span class="line">    I=NIST7035.snp.filter.vcf.gz \</span><br><span class="line">    O=NIST7035.filter.vcf.gz\</span><br><span class="line">    D=$genome.dict</span><br></pre></td></tr></table></figure><h3 id="compare-use-bcftools"><a href="#compare-use-bcftools" class="headerlink" title="compare use bcftools"></a>compare use bcftools</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bcftools isec NIST7035.filter.vcf.gz ref.NIST7035.hc.snps.indels.vcf.gz -p bcftools</span><br><span class="line"><span class="meta">#</span> ref.vcf.gz, alt.vcf.gz 使用 bgzip 压缩，同时 tabix 进行 index</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> output: README.txt</span><br><span class="line"><span class="meta">#</span> This file was produced by vcfisec.</span><br><span class="line"><span class="meta">#</span> The command line was:   bcftools isec  -p bcftools NIST7035.filter.vcf.gz ref.NIST7035.hc.snps.indels.vcf.gz</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Using the following file names:</span><br><span class="line"><span class="meta">#</span> bcftools/0000.vcf  for records private to  NIST7035.filter.vcf.gz</span><br><span class="line"><span class="meta">#</span> bcftools/0001.vcf  for records private to  ref.NIST7035.hc.snps.indels.vcf.gz</span><br><span class="line"><span class="meta">#</span> bcftools/0002.vcf  for records from NIST7035.filter.vcf.gz shared by both  NIST7035.filter.vcf.gz ref.NIST7035.hc.snps.indels.vcf.gz</span><br><span class="line"><span class="meta">#</span> bcftools/0003.vcf  for records from ref.NIST7035.hc.snps.indels.vcf.gz shared by both      NIST7035.filter.vcf.gz ref.NIST7035.hc.snps.indels.vcf.gz</span><br><span class="line"></span><br><span class="line">cat ref.NIST7035.hc.snps.indels.vcf.gz | grep -v '^#' | wc -l    # 54077</span><br><span class="line"></span><br><span class="line">cat 0000.vcf | grep -cv '^#'    # 3863, 假阳性</span><br><span class="line">cat 0001.vcf | grep -cv '^#'    # 2131, 假阴性</span><br><span class="line">cat 0002.vcf | grep -cv '^#'    # 51946</span><br><span class="line">cat 0003.vcf | grep -cv '^#'    # 51946</span><br><span class="line"></span><br><span class="line">cat 0000.vcf| grep -v '^#' | grep PASS | wc -l    # 1334</span><br><span class="line">cat 0002.vcf| grep -v '^#' | grep PASS | wc -l    # 47143</span><br></pre></td></tr></table></figure><p>不考虑snp、indels过滤情况下，计算假阳性、假阴性率。</p><blockquote><p>假阳性: 3863/54077 = 7.14 %</p><p>假阴性: 2131/54077 = 3.94 %</p></blockquote><p>哈哈哈哈，瞎了，没法看的样子。还是考虑下变异过滤结果吧</p><blockquote><p>假阳性: 1334/54077 = 2.46 %</p><p>假阴性: (2131+51946-47143)/54077 = 12.82 %</p></blockquote><p>更加让人没话说，这个假阴性太感人，过滤标准不太合适啊</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 先看被过滤掉的这部分阴性</span><br><span class="line">cat 0002.vcf | grep -v '^#' | grep -v PASS | awk '&#123;n[$7]+=1&#125;END&#123;for (i in n)&#123;print i,n[i]&#125;&#125;'</span><br><span class="line"><span class="meta">#</span> LowDepth 11</span><br><span class="line"><span class="meta">#</span> StrandBias;snp_Filter 277</span><br><span class="line"><span class="meta">#</span> LowDepth;snp_Filter 2</span><br><span class="line"><span class="meta">#</span> InDels_Filter 265</span><br><span class="line"><span class="meta">#</span> StrandBias 3098</span><br><span class="line"><span class="meta">#</span> LowDepth;StrandBias 2</span><br><span class="line"><span class="meta">#</span> snp_Filter 1148</span><br></pre></td></tr></table></figure><p>过滤掉位点最严重的两项分别是<strong>StrandBias</strong>, <strong>snp_Filter</strong>，对应过滤指标分别为<code>FS &gt; 60.0 || SOR &gt; 3.0</code>, <code>QD &lt; 2.0  || MQ &lt; 40.0 || MQRankSum &lt; -12.5</code>，转换vcf文件到tab格式（脚本：<a href="https://github.com/chengcz/BioResource/tree/master/vcf2tab" target="_blank" rel="noopener">github</a>），对其中一些指标进行分布检查。</p><p>先看 <strong>StrandBias</strong>，对 <code>FS</code>,  <code>SOR</code> 两个参数分析，分布结果如下，可看出被过滤的位点基本上都是由于 <strong>SOR</strong> 参数（作图时FS&gt;60无显示），与 <strong>NA12878</strong> 变异集相比，需调整 <strong>SOR</strong> 临界值到更大水平。</p><p><img src="/2018/201806_compare_vcf/./images/2018/StrandBias_density.png" alt=""></p><p>再看 <strong>snp_Filter</strong> 对应的<code>QD &lt; 2.0  || MQ &lt; 40.0 || MQRankSum &lt; -12.5</code>，其中 MQRankSum 对应67个位点，QD 对应557个位点，MQ 对应 1168 个位点，看出 <strong>MQ</strong>, <strong>QD</strong> 标准需要进行调整。</p><p>以现在质控指标对文件<code>0001.vcf</code> <strong>2131</strong> 变异质控，<strong>QD</strong> 过滤掉949，<strong>MQRankSum</strong> 过滤掉14，<strong>MQ</strong> 过滤掉195，<strong>FS</strong> 过滤掉135，根据这部分参考变异集质量指标，同样 <strong>QD</strong>, <strong>MQ</strong>, <strong>FS</strong> 参数需要进行调整。</p><p>另，vcftools 也可以很方便进行两个 vcf 文件的比较，还没 bcftools 对 vcf 文件必须排序、index的要求，输出结果也相应不同，因为我需要看阳性、阴性位点是否被过滤以及过滤情况，就不再用 vcftools 整理了，具体命令可参考如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> http://vcftools.github.io/</span><br><span class="line">vcftools --vcf ref.vcf --diff alt.vcf --out prefix</span><br><span class="line"><span class="meta">#</span> ref.vcf.gz    # 则需要使用--gzvcf</span><br><span class="line"><span class="meta">#</span> alt.vcf.gz    # 则需要使用--gzdiff</span><br></pre></td></tr></table></figure><h3 id="质控参数调整思路"><a href="#质控参数调整思路" class="headerlink" title="质控参数调整思路"></a>质控参数调整思路</h3><p>根据质控结果比较来看，参控参数都还需要进行再调整，一个初步的参数调整思路是，对高质量变异集各项质控指标分布进行统计，然后进行阈值选择；或者对 <strong>NA12878</strong> 全基因组水平的变异进行 <strong><a href="https://software.broadinstitute.org/gatk/documentation/article.php?id=2805" target="_blank" rel="noopener">VQSR</a></strong> 分析，统计高质量变异位点质控指标分布</p>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WES </tag>
            
            <tag> NA12878 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vcf 注释 —— ANNOVAR</title>
      <link href="/2018/201806_ANNOVAR/"/>
      <url>/2018/201806_ANNOVAR/</url>
      <content type="html"><![CDATA[<p>最先知道的 VCF 注释软件，但是呢没有搞定构建研究物种的注释数据库，于是转向snpEff，工作转向临床分析时候，发现 ANNOVAR 在人类数据注释多种第三方数据库支持，变异频率、HGVS、ACMG致病性、dbSNP、Cosmic支持等等</p><p>软件文档镇楼: <a href="http://annovar.openbioinformatics.org/en/latest/" target="_blank" rel="noopener">http://annovar.openbioinformatics.org/en/latest/</a></p><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p>ANNOVAR 由 perl 实现，下载即用，软件下载地址为：<a href="http://www.openbioinformatics.org/annovar/annovar_download_form.php" target="_blank" rel="noopener">http://www.openbioinformatics.org/annovar/annovar_download_form.php</a> ，软件包包括下面几个功能脚本：</p><ul><li><em>annotate_variation.pl</em>, 主程序，数据库下载，变异注释等等</li><li><em>coding_change.pl</em>, 推断蛋白序列的变化</li><li><em>convert2annovar.pl</em>, </li><li><em>retrieve_seq_from_fasta.pl</em>, </li><li><em>table_annovar.pl</em>, 注释程序，根据数据库选择完成不同类型变异注释</li><li><em>variants_reduction.pl</em>, </li></ul><h3 id="数据库下载、整理"><a href="#数据库下载、整理" class="headerlink" title="数据库下载、整理"></a>数据库下载、整理</h3><p>ANNOVAR 注释变异可以分成有基于基因、基于染色体区间和变异数据等三种类型</p><ol><li><p>基于gene的注释</p><p>注释结果为突变位点位于基因的相对位置，是否改变氨基酸编码，获得变异位点的HGVS命名方式</p></li><li><p>基于染色体区间的注释</p><p>获取变异位点是否存在于某些特定的区间内，Identify cytogenetic band, 转录因子结合区等等</p></li><li><p>变异数据库的注释</p><p>包括Clinvar, dbSNP, Cosmic, ExAC, gnomAD等等，突变数据库整理可参考<a href="https://chengcz.github.io/2018/201806_vcf2tab/index.html"><strong><em>从 vcf 文件准备 ANNOVAR 数据库</em></strong></a></p></li></ol><p>ANNOVAR 数据库文件实际上为特定格式的文本文件，其数据库文件命名规则为:  <strong>\${path_database}/\${buildver}_\${database_name}.txt</strong></p><h3 id="软件运行"><a href="#软件运行" class="headerlink" title="软件运行"></a>软件运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> input file format: vcf</span><br><span class="line">table_annovar.pl example/ex2.vcf humandb/ -buildver hg19 -out myanno -remove -protocol refGene,cytoBand,esp6500siv2_all,1000g2015aug_all,1000g2015aug_afr,1000g2015aug_eas,1000g2015aug_eur,snp138,dbnsfp30a -operation g,r,f,f,f,f,f,f,f -nastring . -vcfinput</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 不同于snpEff，ANNOVAR 所有注释结果都在 vcf 文件 INFO 列添加key-value</span><br></pre></td></tr></table></figure><h3 id="非人物种数据库整理"><a href="#非人物种数据库整理" class="headerlink" title="非人物种数据库整理"></a>非人物种数据库整理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载物种基因序列、注释文件</span><br><span class="line">wget -c ftp://ftp.ensemblgenomes.org/pub/release-27/plants/fasta/arabidopsis_thaliana/dna/Arabidopsis_thaliana.TAIR10.27.dna.genome.fa.gz</span><br><span class="line">wget -c ftp://ftp.ensemblgenomes.org/pub/release-27/plants/gtf/arabidopsis_thaliana/Arabidopsis_thaliana.TAIR10.27.gtf.gz</span><br><span class="line">gzip -d Arabidopsis_thaliana.TAIR10.27.dna.genome.fa.gz</span><br><span class="line">gzip -d Arabidopsis_thaliana.TAIR10.27.gtf.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> gtf文件格式转换</span><br><span class="line">gtfToGenePred -genePredExt Arabidopsis_thaliana.TAIR10.27.gtf AT_refGene.txt</span><br><span class="line"><span class="meta">#</span> wget -c http://hgdownload.cse.ucsc.edu/admin/exe/linux.x86_64/gtfToGenePred</span><br><span class="line"><span class="meta">#</span> 另一种格式转换方法，https://github.com/chengcz/pyGTF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用软件包提供脚本build物种数据库，数据库buildver为AT，名称为refGene</span><br><span class="line">perl retrieve_seq_from_fasta.pl --format refGene --seqfile Arabidopsis_thaliana.TAIR10.27.dna.genome.fa AT_refGene.txt --out AT_refGeneMrna.fa</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从 vcf 文件准备 ANNOVAR 数据库</title>
      <link href="/2018/201806_vcf2tab/"/>
      <url>/2018/201806_vcf2tab/</url>
      <content type="html"><![CDATA[<p>annovar可以说是最常用的变异注释软件了，除了基于基因位置进行注释，还有丰富的第三方数据库支持，clinvar, cosmic等等，但是annovar提供下载数据库版本较老，需要自行下载第三方 vcf 进行转换。</p><p>以 clinvar 为例说说 vcf 格式转换成 annovar 可识别表格格式，annovar 仅需要 vcf 中部分信息，为了脚本通用这里输出vcf所有信息到 tab 格式，详细处理脚本如下，同时实现脚本存放 <a href="https://github.com/chengcz/BioResource/tree/master/vcf2tab" target="_blank" rel="noopener">github</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Parse_Variant_Annovar_Style</span><span class="params">(line)</span>:</span></span><br><span class="line">CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO = line.split(<span class="string">'\t'</span>)[:<span class="number">8</span>]</span><br><span class="line">    <span class="comment"># 一般公共数据下载的 vcf 文件仅包含8列</span></span><br><span class="line">    POS = int(POS)</span><br><span class="line">    dat = &#123;&#125;</span><br><span class="line">    dat[<span class="string">'CHROM'</span>] = CHROM</span><br><span class="line">    dat[<span class="string">'ID'</span>] = ID</span><br><span class="line">    <span class="keyword">if</span> len(REF) == len(ALT) == <span class="number">1</span> <span class="keyword">and</span> REF != ALT:    <span class="comment"># SNV</span></span><br><span class="line">        dat[<span class="string">'START'</span>], dat[<span class="string">'END'</span>] = POS, POS</span><br><span class="line">        dat[<span class="string">'REF'</span>], dat[<span class="string">'ALT'</span>] = REF, ALT</span><br><span class="line">    <span class="keyword">elif</span> len(REF) == <span class="number">1</span> <span class="keyword">and</span> len(ALT) != <span class="number">1</span> <span class="keyword">and</span> ALT.startswith(REF):    <span class="comment"># Insert</span></span><br><span class="line">        dat[<span class="string">'START'</span>], dat[<span class="string">'END'</span>] = POS, POS</span><br><span class="line">        dat[<span class="string">'REF'</span>], dat[<span class="string">'ALT'</span>] = <span class="string">'-'</span>, ALT[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">elif</span> len(REF) != <span class="number">1</span> <span class="keyword">and</span> len(ALT) == <span class="number">1</span> <span class="keyword">and</span> REF.startswith(ALT):    <span class="comment"># Delete</span></span><br><span class="line">        dat[<span class="string">'START'</span>], dat[<span class="string">'END'</span>] = POS+<span class="number">1</span>, POS+len(REF)<span class="number">-1</span></span><br><span class="line">        dat[<span class="string">'REF'</span>], dat[<span class="string">'ALT'</span>] = REF[<span class="number">1</span>:], <span class="string">'-'</span></span><br><span class="line">    <span class="keyword">else</span>:    <span class="comment"># complex variant</span></span><br><span class="line">        dat[<span class="string">'START'</span>], dat[<span class="string">'END'</span>] = POS, POS+len(REF)<span class="number">-1</span></span><br><span class="line">        dat[<span class="string">'REF'</span>], dat[<span class="string">'ALT'</span>] = REF, ALT</span><br><span class="line">    dat.update(INFO2dict(INFO))</span><br><span class="line">    <span class="keyword">return</span> dat</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Parse_Variant</span><span class="params">(line)</span>:</span></span><br><span class="line">CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO = line.split(<span class="string">'\t'</span>)[:<span class="number">8</span>]</span><br><span class="line">    <span class="comment"># 一般公共数据下载的 vcf 文件仅包含8列</span></span><br><span class="line">    POS = int(POS)</span><br><span class="line">    dat = &#123;&#125;</span><br><span class="line">    dat[<span class="string">'CHROM'</span>] = CHROM</span><br><span class="line">    dat[<span class="string">'ID'</span>] = ID</span><br><span class="line">    dat[<span class="string">'START'</span>], dat[<span class="string">'END'</span>] = POS, POS+len(REF)<span class="number">-1</span></span><br><span class="line">    dat[<span class="string">'REF'</span>], dat[<span class="string">'ALT'</span>] = REF, ALT</span><br><span class="line">    dat.update(INFO2dict(INFO))</span><br><span class="line">    <span class="keyword">return</span> dat</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">INFO2dict</span><span class="params">(info)</span>:</span></span><br><span class="line">    tmp = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> info.split(<span class="string">';'</span>) <span class="keyword">if</span> i.strip()]</span><br><span class="line">    infor = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'='</span> <span class="keyword">in</span> i:</span><br><span class="line">            <span class="comment"># index = i.index('=')</span></span><br><span class="line">            <span class="comment"># infor[i[:index]] = i[index+1:]</span></span><br><span class="line">            i = i.split(<span class="string">'='</span>)</span><br><span class="line">            infor[i[<span class="number">0</span>]] = i[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            infor[i] = <span class="string">'true'</span></span><br><span class="line">    <span class="keyword">return</span> infor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fopen = gzip.open <span class="keyword">if</span> clinvar.endswith(<span class="string">'gz'</span>) <span class="keyword">else</span> open</span><br><span class="line"><span class="comment"># 这种文件打开适用于 python2, python3 中存在 bits 和 string 类型的差别</span></span><br><span class="line"><span class="keyword">with</span> fopen(input_vcf) <span class="keyword">as</span> f:</span><br><span class="line">    tags = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i.strip():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i.startswith(<span class="string">'##INFO='</span>):</span><br><span class="line">             tags.append(i.split(<span class="string">','</span>)[<span class="number">0</span>].split(<span class="string">'='</span>)[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">elif</span> i.startswith(<span class="string">'#CHROM'</span>):</span><br><span class="line">             print(<span class="string">'#CHROM\tSTART\tEND\tID\tREF\tALT\t&#123;&#125;\n'</span>.format(<span class="string">'\t'</span>.join(tags)))</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> i.startswith(<span class="string">'#'</span>):</span><br><span class="line">             dat = Parse_Variant_Annovar_Style(i)</span><br><span class="line">             <span class="comment"># dat = Parse_Varitn(i)</span></span><br><span class="line">             <span class="keyword">for</span> x, label <span class="keyword">in</span> enumerate([<span class="string">'CHROM'</span>, <span class="string">'START'</span>, <span class="string">'END'</span>, <span class="string">'ID'</span>, <span class="string">'REF'</span>, <span class="string">'ALT'</span>]+tags):</span><br><span class="line">                <span class="keyword">if</span> x != <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">'\t'</span>)</span><br><span class="line">                print(dat.get(label, <span class="string">'--'</span>))    <span class="comment"># INFO 列中某些 tag 并不存在于所有行</span></span><br><span class="line">             print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编写 python 的几种 config 处理方式</title>
      <link href="/2018/201805_config/"/>
      <url>/2018/201805_config/</url>
      <content type="html"><![CDATA[<p>编写分析流程时候，为了兼容性总会设置一些常用选项配置文件输入，不同配置方式各有一些特点，就用过的几种配置方式简单整理</p><h3 id="script-——-config-py"><a href="#script-——-config-py" class="headerlink" title="script —— config.py"></a>script —— config.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># sys.path.insert(0, 'config_py_dirname')    # 使config.py文件位于PYTHONPATH路径下</span></span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">option = config.option    <span class="comment"># 获取配置信息</span></span><br></pre></td></tr></table></figure><p>书写方式完全按照python脚本进行，可读性较高，问题在于<strong>PYTHONPATH的处理</strong>，脚本环境内<strong>键值对可能产生的覆盖问题</strong>，准确导入分析流程</p><h3 id="configparser-——-config-ini"><a href="#configparser-——-config-ini" class="headerlink" title="configparser —— config.ini"></a>configparser —— config.ini</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser    <span class="comment"># python3</span></span><br><span class="line"><span class="comment"># import Configparser as configparser    # python2</span></span><br><span class="line"></span><br><span class="line">cf = configparser.ConfigParser()</span><br><span class="line">cf.read(<span class="string">'config.ini'</span>)</span><br><span class="line"></span><br><span class="line">sections = cf.sections()    <span class="comment"># 列出所有section</span></span><br><span class="line">options = cf.options(section)    <span class="comment"># 列出section对应的所有option</span></span><br><span class="line">value = cf.get(section,option)    <span class="comment"># 范围section对应option的值，string</span></span><br><span class="line"><span class="comment"># getint(section,option) 返回为int，</span></span><br><span class="line"><span class="comment"># getboolean(section,option) 返回bool，</span></span><br><span class="line"><span class="comment"># getfloat(section,option) 返回float</span></span><br></pre></td></tr></table></figure><p>但是，<strong>在configparser模块中不区分section, option大小写，一次读取一条配置信息</strong></p><h3 id="json-——-config-json"><a href="#json-——-config-json" class="headerlink" title="json —— config.json"></a>json —— config.json</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒入配置json到python环境，config类型跟json内容相关</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'config.json'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = json.load(f)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出python对象到json文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'whatever.josn'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(config, f, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>json文件格式要求较严格，书写配置文件容易手误出错，相比之下<strong>更适用于流程中数据传递</strong></p><h3 id="yaml-——-config-yaml"><a href="#yaml-——-config-yaml" class="headerlink" title="yaml —— config.yaml"></a>yaml —— config.yaml</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'config.yaml'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = yaml.load(f)     <span class="comment"># dict OR list</span></span><br></pre></td></tr></table></figure><h4 id="YAML-语法规则"><a href="#YAML-语法规则" class="headerlink" title="YAML 语法规则"></a>YAML 语法规则</h4><ul><li>大小写敏感 </li><li>使用缩进表示层级关系 </li><li>使用空格缩进,不允许使用Tab键</li><li>相同层级的元素左侧对齐即可</li><li>使用 <strong>#</strong> 作为注释符号</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示 key-value 对</span></span><br><span class="line"><span class="attr">key1:</span> <span class="string">value2</span></span><br><span class="line"><span class="attr">key2:</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示 list</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">value2</span></span><br><span class="line"><span class="comment"># [value1, value2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间表示</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-05</span><span class="bullet">-24</span>    <span class="comment"># iso8601</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># None表示</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">~</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bool表示</span></span><br><span class="line"><span class="attr">flag1:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">flag2:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>相比于上面几种方法，<strong>yaml可读性高，容易书写，不用考虑PYTHONPATH问题，批量导入配置信息</strong></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HGVS 变异描述规则</title>
      <link href="/2018/201805_HGVS/"/>
      <url>/2018/201805_HGVS/</url>
      <content type="html"><![CDATA[<p><a href="http://varnomen.hgvs.org/recommendations/" target="_blank" rel="noopener">http://varnomen.hgvs.org/recommendations/</a>, 描述规则基本格式为：<strong>[identifier]:[levels].[Description of variant]</strong></p><h3 id="identifier"><a href="#identifier" class="headerlink" title="[identifier]"></a>[identifier]</h3><p><img src="/2018/201805_HGVS/./images/2018/hgvs_identifier.png" alt=""></p><ul><li>only public files from NCBI or EBI are accepted as reference sequence files</li><li>a reference sequence file identifier should contain both the <strong>accession</strong> and <strong>version number</strong></li><li>specifications to a specific annotated segment of a reference sequence can be given in parentheses directly after the reference sequence</li><li>the reference sequence used <strong>must contain</strong> the variant residue described</li></ul><p>其他具体要求描述可以参考：<a href="http://varnomen.hgvs.org/bg-material/refseq/" target="_blank" rel="noopener">http://varnomen.hgvs.org/bg-material/refseq/</a></p><h3 id="levels"><a href="#levels" class="headerlink" title="[levels]"></a>[levels]</h3><p><img src="/2018/201805_HGVS/./images/2018/hgvs_prefix.png" alt=""></p><p>Reference Sequence Types主要有g, c, n, m, r, p六种，其中c, p, g使用最多</p><h3 id="Description-of-variant"><a href="#Description-of-variant" class="headerlink" title="[Description of variant]"></a>[Description of variant]</h3><ul><li>替换<ul><li>cDNA: <code>c.255C&gt;A</code></li><li>protein: <code>p.Trp24Cys</code>, <code>p.Trp24*</code>, <code>p.Cys188=</code></li></ul></li><li>缺失<ul><li>cDNA: <code>c.19_21del</code></li><li>protein: <code>p.Lys23_Val25del</code></li></ul></li><li>插入<ul><li>cDNA: <code>c.240_241insAGG</code></li><li>protein: <code>p.Lys2_Gly3insGlnSerLys</code></li></ul></li><li>重复<ul><li>cDNA: <code>c.20_23dup</code></li><li>protein: <code>p.Ser6dup</code></li></ul></li><li>插入缺失<ul><li>cDNA: <code>c.142_144delinsTGG</code></li><li>protein: <code>p.Arg48Trp</code></li></ul></li><li>移码突变<ul><li>protein: <code>p.Arg97fs</code></li></ul></li></ul><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ul><li>坐标系统为 1-based, <img src="/2018/201805_HGVS/./images/2018/hgvs_loc.png" alt=""></li><li>描述核酸和蛋白变异的差别，<code>g.123A&gt;G</code> 和 <code>p.Trp26Ter</code></li><li>可使用在线网站 <a href="https://mutalyzer.nl/" target="_blank" rel="noopener">mutalyzer</a> 检验变异描述是否合规，也可进行c -&gt; g坐标转换等等</li></ul><p>###<strong>Ref</strong>:</p><ul><li>DOI: <a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/humu.22981" target="_blank" rel="noopener">10.1002/humu.22981</a></li><li><a href="http://varnomen.hgvs.org/recommendations/general" target="_blank" rel="noopener">http://varnomen.hgvs.org/recommendations/general</a></li></ul>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HGVS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 表格处理 —— pandas</title>
      <link href="/2018/201805_pandas/"/>
      <url>/2018/201805_pandas/</url>
      <content type="html"><![CDATA[<p>pandas 表格数据处理，唰唰唰…</p><h2 id="Data-frame"><a href="#Data-frame" class="headerlink" title="Data frame"></a>Data frame</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据框转制</span></span><br><span class="line">dat = dat.T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据列进行合并</span></span><br><span class="line">dat = pd.merge(dat1, dat2, </span><br><span class="line">               on=<span class="string">'col'</span>,    <span class="comment"># col在两个数据框中同时存在时，设置on</span></span><br><span class="line">               left_on=<span class="string">'col1'</span>, right_on=<span class="string">'col2'</span>,    <span class="comment"># 两个列名不同时存在，分贝设置合并列名</span></span><br><span class="line">               left_index=<span class="keyword">False</span>, right_index=<span class="keyword">False</span>,    <span class="comment"># 使用df的index进行合并</span></span><br><span class="line">               how=<span class="string">'outdir'</span>)    <span class="comment"># &#123;'left', 'right', 'outer', 'inner'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># concat 合并列数据</span></span><br><span class="line">dat = pd.concat(dflst, </span><br><span class="line">                axis=<span class="number">1</span>,    <span class="comment"># 左右合并</span></span><br><span class="line">                join=<span class="string">'outer'</span>)    <span class="comment"># &#123;'inner', 'outer'&#125;</span></span><br><span class="line"><span class="comment"># concat 行追加</span></span><br><span class="line">dat = pd.concat(dflst, axis=<span class="number">0</span>, ignore_index=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据框行或者列</span></span><br><span class="line">dat = dat.drop(col_lst, axis=<span class="number">1</span>)    <span class="comment"># 删除 列</span></span><br><span class="line">dat = dat.drop(index_lst, axis=<span class="number">0</span>)    <span class="comment"># 删除 行</span></span><br><span class="line">dat = dat.drop_duplicates()    <span class="comment"># 删除 重复行</span></span><br><span class="line">dat = dat.dropna(axis=<span class="number">0</span>,     <span class="comment"># 0，1 0表示行，1表示列</span></span><br><span class="line">                 how=<span class="string">'all'</span>)    <span class="comment"># &#123;'any', 'all'&#125;, all表示删除所有值缺失，any表示删除任意一个值缺失</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长表格 ==&gt; 宽表格转换</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">dat = pd.pivot_table(df, index=[<span class="string">"Product"</span>],    <span class="comment"># 设置保留字段</span></span><br><span class="line">                     columns=[<span class="string">'Year'</span>],    <span class="comment"># 扩展列</span></span><br><span class="line">                     values=[<span class="string">"Price"</span>],    <span class="comment"># 选定列对应数值</span></span><br><span class="line">                     aggfunc=[np.sum], fill_value=<span class="number">0</span>)    <span class="comment"># 设置数据合并的具体操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 宽表格 ==&gt; 长表格转换</span></span><br><span class="line">df = df.melt(id_vars=[<span class="string">"Name"</span>,<span class="string">"Product"</span>],    <span class="comment"># 保留的主字段</span></span><br><span class="line">             var_name=<span class="string">"Year"</span>,    <span class="comment"># 分类名</span></span><br><span class="line">             value_name=<span class="string">"Price"</span>)    <span class="comment"># 变量名</span></span><br></pre></td></tr></table></figure><h2 id="read-table"><a href="#read-table" class="headerlink" title="read table"></a>read table</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dat = pd.read_table(<span class="string">'data.csv'</span>, </span><br><span class="line">                    sep=<span class="string">'\t'</span>,     <span class="comment"># 设置表格分隔符，read_table默认为‘\t’，read_csv默认为‘,’</span></span><br><span class="line">                    index_col=<span class="number">0</span>,    <span class="comment"># 使用第1列作为数据框index，默认range(0, num_line)作为index</span></span><br><span class="line">                    header=<span class="keyword">None</span>,     <span class="comment"># 表示文件不存在表头，默认第一行为表头</span></span><br><span class="line">                    names=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>])    <span class="comment"># 表头不存在时，添加表头为...</span></span><br><span class="line"><span class="comment"># dat = pd.read_csv(...)</span></span><br><span class="line">dat = pd.read_excel(<span class="string">'data.xlsx'</span>, </span><br><span class="line">                    sheet_name=<span class="string">'sheet1'</span>)    <span class="comment"># 读取data.xlsx工作簿中sheet1的表格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件前特定行数</span></span><br><span class="line">dat = pd.read_csv(<span class="string">'data.csv'</span>, nrows=<span class="number">500</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取超大文件</span></span><br><span class="line">reader = pd.read_csv(<span class="string">'data.csv'</span>, </span><br><span class="line">                     iterator=<span class="keyword">True</span>)    <span class="comment"># 产生一个迭代器</span></span><br><span class="line">chunkSize = <span class="number">100000</span></span><br><span class="line">chunks = []</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        chunk = reader.get_chunk(chunkSize)    <span class="comment"># 一次读取特定行</span></span><br><span class="line">        <span class="comment"># chunk     # 进行一些过滤、处理</span></span><br><span class="line">        chunks.append(chunk)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">df = pd.concat(chunks, axis=<span class="number">0</span>, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h2 id="save-table"><a href="#save-table" class="headerlink" title="save table"></a>save table</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数据到txt文本</span></span><br><span class="line">dat.to_csv(<span class="string">'data.xls'</span>, </span><br><span class="line">           index=<span class="keyword">False</span>,    <span class="comment"># 是否输出df的index</span></span><br><span class="line">           header=<span class="keyword">False</span>,    <span class="comment"># 是否输出表头</span></span><br><span class="line">           na_rep=<span class="string">''</span>,    <span class="comment"># 缺省值替换</span></span><br><span class="line">           sep=<span class="string">'\t'</span>,    <span class="comment"># 使用tab作为分隔符</span></span><br><span class="line">           encoding=<span class="string">'utf-8'</span>)    <span class="comment"># 输出文件使用utf-8编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数据框到excel</span></span><br><span class="line">writer = pd.ExcelWriter(<span class="string">'output.xlsx'</span>)    <span class="comment"># 创建输出文件</span></span><br><span class="line">df1.to_excel(writer, </span><br><span class="line">             sheet_name=<span class="string">'Sheet1'</span>, )    <span class="comment"># 输出到工作簿中名为Sheet1的工作表</span></span><br><span class="line">df2.to_excel(writer, </span><br><span class="line">             sheet_name=<span class="string">'Sheet2'</span>, )    <span class="comment"># 输出到工作簿中名为Sheet2的工作表</span></span><br><span class="line"><span class="comment"># ... </span></span><br><span class="line">writer.save()    <span class="comment"># 保存工作簿</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python 执行 linux 命令 —— subprocess</title>
      <link href="/2018/201805_subprocess/"/>
      <url>/2018/201805_subprocess/</url>
      <content type="html"><![CDATA[<p>python 脚本内执行 linux 命令有多种方式，os.system(), os.popen()也可以，官方最新推荐方式为subprocess</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行cmd并等待运行结束，返回执行状态码</span></span><br><span class="line">subprocess.call(<span class="string">'ls'</span>, shell=<span class="keyword">True</span>)    <span class="comment"># 与 os.system() 功能相似</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行cmd并等待运行结束，返回执行状态码</span></span><br><span class="line">subprocess.check_call(<span class="string">'ls'</span>, shell=<span class="keyword">True</span>)    <span class="comment"># 与subprocess.call()不同，returncode不为0，触发CalledProcessError异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行cmd并等待运行结束，返回 /dev/stdout 信息</span></span><br><span class="line">subprocess.check_output(<span class="string">'ls'</span>, shell=<span class="keyword">True</span>, </span><br><span class="line">                        universal_newlines=<span class="keyword">True</span>)    <span class="comment"># 以 string 形式返回 stdout 信息，而不是bytes，与 os.popen() 功能相似</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不等待 cmd 运行结束</span></span><br><span class="line">job = subprocess.Popen(<span class="string">'ls -l'</span>,    <span class="comment"># string of cmd</span></span><br><span class="line">                       shell=<span class="keyword">True</span>,    <span class="comment"># 传入参数作为 shell 进行执行</span></span><br><span class="line">                       stdout=subprocess.PIPE,    <span class="comment"># 输出标准输出到subprocess流程</span></span><br><span class="line">                       stderr=subprocess.PIPE,    <span class="comment"># 输出标准错误到subprocess流程</span></span><br><span class="line">                       universal_newlines=<span class="keyword">True</span>)    <span class="comment"># stdout 返回时，使用 string 代替 bytes 类型</span></span><br><span class="line">pid = job.pid    <span class="comment"># 获得 cmd 本地执行的 pid</span></span><br><span class="line">job.wait()    <span class="comment"># 等待工作结束，默认Popen不等待 cmd 执行完毕即退出</span></span><br><span class="line">stdout, stderr = job.communicate()    <span class="comment"># 获得 cmd 执行返回标准输出、标准错误</span></span><br><span class="line"><span class="comment"># 设置 stdin=subprocess.PIPE 时，可以在communicate(input='...')传入参数</span></span><br><span class="line">job.returncode    <span class="comment"># 获得 cmd 执行状态码</span></span><br><span class="line">job.kill()    <span class="comment"># 杀死 cmd 进程</span></span><br></pre></td></tr></table></figure><p>os 模块实现 linux cmd 执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'ls -l'</span>)    <span class="comment"># 直接返回 cmd 执行状态码</span></span><br><span class="line"><span class="comment"># assert not os.system('ls')</span></span><br><span class="line">os.popen(<span class="string">'ls -l'</span>)    <span class="comment"># 以文件句柄的方式返回 cmd 执行的stdout信息</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python 参数解析 —— argsparse</title>
      <link href="/2018/201805_argparse/"/>
      <url>/2018/201805_argparse/</url>
      <content type="html"><![CDATA[<p>argsparse 解析命令行参数，一些常用参数整理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(<span class="comment"># prog=__file__,    # 设置项目名称，__file__ 与 sys.argv[0] 一致，默认显示为 basename(__file__)</span></span><br><span class="line">      usage=<span class="string">'''</span></span><br><span class="line"><span class="string">      python %(prog)s [option]  '''</span>,    <span class="comment"># 设置脚本输出默认 USAGE 信息</span></span><br><span class="line">      description=<span class="string">''' some script description '''</span>,   <span class="comment"># 脚本功能描述等等</span></span><br><span class="line">      formatter_class=argparse.RawTextHelpFormatter,    <span class="comment"># 以脚本内原始文档格式输出描述等信息</span></span><br><span class="line">      epilog=<span class="string">'''</span></span><br><span class="line"><span class="string">      Note and input example, and so on.  '''</span>)    <span class="comment"># 脚本描述以外的其他信息</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'-v'</span>, <span class="string">'--version'</span>,    <span class="comment"># 添加脚本版本信息参数</span></span><br><span class="line">                    action=<span class="string">'version'</span>,</span><br><span class="line">                    version=<span class="string">'%(prog)s 2.0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个普通的可选参数</span></span><br><span class="line">parser.add_argument(<span class="string">'-e'</span>,    <span class="comment"># 短参数</span></span><br><span class="line">                    <span class="string">'--example'</span>,    <span class="comment"># 长参数</span></span><br><span class="line">                    dest=<span class="string">'example'</span>,     <span class="comment"># 参数对应模块内部，唯一标识符</span></span><br><span class="line">                    metavar=<span class="string">''</span>,    <span class="comment"># 设置help信息中参数后字符</span></span><br><span class="line">                    action=<span class="string">'store'</span>,    <span class="comment"># 参数处理方式</span></span><br><span class="line">                    type=str,    <span class="comment"># 传入参数类型</span></span><br><span class="line">                    choices=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],    <span class="comment"># 参数选择范围</span></span><br><span class="line">                    required=<span class="keyword">True</span>,    <span class="comment"># 表示该参数必须被设置</span></span><br><span class="line">                    default=<span class="string">'a'</span>,    <span class="comment"># 参数缺省时，该参数默认值</span></span><br><span class="line">                    nargs=<span class="string">'+'</span>,    <span class="comment"># 参数个数，*+？，表示至少一个输入</span></span><br><span class="line">                    help=<span class="string">'some help infor'</span>)    <span class="comment"># help信息</span></span><br><span class="line"><span class="comment"># action属性为store_true, store_false, store_const时，参数不接任何输入信息</span></span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>,</span><br><span class="line">                    dest=<span class="string">'accumulate'</span>,</span><br><span class="line">                    action=<span class="string">'store_const'</span>,    <span class="comment"># 该参数被设置时，参数取值成 const 对应值</span></span><br><span class="line">                    const=sum,</span><br><span class="line">                    default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"><span class="comment"># 位置参数</span></span><br><span class="line">parser.add_argument(<span class="string">'pos'</span>,</span><br><span class="line">                    dest=<span class="string">'pos_argument'</span>,</span><br><span class="line">                    metavar=<span class="string">''</span>,</span><br><span class="line">                    nargs=<span class="string">'+'</span>,    <span class="comment"># 参数输入文件个数</span></span><br><span class="line">                    help=<span class="string">'some help infor'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 互斥参数组，组内参数不可同时出现，required=True表示组内必须有参数被设置</span></span><br><span class="line">exclusive = parser.add_mutually_exclusive_group(required=<span class="keyword">True</span>)    </span><br><span class="line">exclusive.add_argument(<span class="string">'-a'</span>, )</span><br><span class="line">exclusive.add_argument(<span class="string">'-b'</span>, )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置多个参数为一组，无实际意义，仅在打印help信息时，分组显示</span></span><br><span class="line">group = parser.add_argument_group(<span class="string">'argument group info'</span>)    </span><br><span class="line">group.add_argument(<span class="string">'-c'</span>, )</span><br><span class="line">group.add_argument(<span class="string">'-d'</span>, )</span><br><span class="line"></span><br><span class="line"><span class="comment"># parse.print_help()</span></span><br><span class="line">args = parser.parse_args()    <span class="comment"># 参数解析，生成可调用对象</span></span><br><span class="line"></span><br><span class="line">example = args.example</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 topaht2-fusion 分析 Fusion-Gene</title>
      <link href="/2018/201805_TophatFusion/"/>
      <url>/2018/201805_TophatFusion/</url>
      <content type="html"><![CDATA[<p>tophat2-fusion 文档搬运工：<a href="https://ccb.jhu.edu/software/tophat/fusion_tutorial.shtml" target="_blank" rel="noopener">https://ccb.jhu.edu/software/tophat/fusion_tutorial.shtml</a></p><p>###step1.tophat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tophat2 -p 8 -o $OUTPUT --fusion-search --keep-fasta-order --bowtie1 --no-coverage-search --fusion-anchor-length 10 --fusion-min-dist 100000 --mate-inner-dist 40 --mate-std-dev 100 $hg_bowtie1_index $read1.fastq.gz $read2.fastq.gz</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p><em>–fusion-search</em>，融合 reads 搜索</p><p><em>–keep-fasta-order</em>,</p><p><em>–bowtie1</em>，使用 bowtie1 代替 bowtie2 进行 reads 比对。需要使用 bowtie-1.1.2，最新版本 1.2.2 会报错</p><p><img src="/2018/201805_TophatFusion/./images/2018/bowtie1.2_TophatFusion.png" alt=""></p><p><em>–no-coverage-search</em>,</p><p><em>–fusion-anchor-length 10</em> ,</p><p><em>–fusion-min-dist 100000</em> ,</p><p><em>–mate-inner-dist 40</em> ,</p><p><em>–mate-std-dev 100</em> ,</p><p>###step2.tophat-fusion-post</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tophat-fusion-post -p 8 --num-fusion-reads 1 --num-fusion-pairs 2 --num-fusion-both 5 $hg_bowtie1_index</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>–num-fusion-reads* , 支持融合的最少 reads 数目</p><p><em>–num-fusion-pairs</em>, 支持融合事件的最少配对 reads 数，表示为跨越融合点的测序片段</p><p><em>–num-fusion-both</em>,  支持融合的最少 reads，包括跨越的 reads 对和 split reads</p><p><em>–fusion-read-mismatches</em>, Reads support fusions if they map across fusion with at most this many mismatches. The default is 2.</p><p><em>–fusion-multireads</em>, Reads that map to more than this many places will be ignored. The default is 2.</p><p><em>–non-human</em>, If your annotation is different from that of human, use the option.</p><p><em>–fusion-pair-dist</em>, Pairs with this specified distance are counted as supporting evidence for the fusion. The default threshold for the inner distance is 250.</p><h3 id="results"><a href="#results" class="headerlink" title="results"></a>results</h3><p>测试了多个样品，多个参数，也根据官网数据、命令运行项目，都没有发现任何融合结果，bug还是打开方式不对</p>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FusionGene </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 STAR-fusion 分析 Fusion-Gene</title>
      <link href="/2018/201805_STARFusion/"/>
      <url>/2018/201805_STARFusion/</url>
      <content type="html"><![CDATA[<p>软件文档：<a href="https://github.com/STAR-Fusion/STAR-Fusion/wiki" target="_blank" rel="noopener">https://github.com/STAR-Fusion/STAR-Fusion/wiki</a></p><p>##软件安装</p><ol><li>STAR，<a href="https://github.com/alexdobin/STAR" target="_blank" rel="noopener">https://github.com/alexdobin/STAR</a></li><li>运行依赖 perl 模块<ol><li>DB_File</li><li>URI::Escape</li><li>Set::IntervalTree</li><li>Carp::Assert</li><li>JSON::XS</li><li>PerlIO::gzip</li><li>common::sense</li><li>Types::Serialiser</li><li>Canary::Stability</li></ol></li></ol><p>##数据库准备</p><p>下载一个较小的未处理的参考文件，自己运行 index 命令。要是网速够快也可以直接在 index 好的数据库文件，~27G</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://data.broadinstitute.org/Trinity/CTAT_RESOURCE_LIB/GRCh37_v19_CTAT_lib_Feb092018.source_data.tar.gz</span><br><span class="line"><span class="meta">$</span>STAR_FUSION_HOME/FusionFilter/prep_genome_lib.pl \</span><br><span class="line">    --genome_fa ref_genome.fa \</span><br><span class="line">    --gtf ref_annot.gtf \</span><br><span class="line">    --fusion_annot_lib CTAT_HumanFusionLib.v0.1.0.dat.gz \</span><br><span class="line">    --annot_filter_rule AnnotFilterRule.pm \</span><br><span class="line">    --pfam_db PFAM.domtblout.dat.gz</span><br></pre></td></tr></table></figure><p>##运行STAR-Fusion</p><p><strong>STAR-Fusion</strong>  对 STAR 输出的嵌合比对分析发现可能存在的基因融合事件</p><h3 id="从-fastq-文件开始"><a href="#从-fastq-文件开始" class="headerlink" title="从 fastq 文件开始"></a>从 fastq 文件开始</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>STAR_FUSION_HOME/STAR-Fusion \</span><br><span class="line">    --genome_lib_dir /path/to/your/CTAT_resource_lib \</span><br><span class="line">    --left_fq reads_1.fq \</span><br><span class="line">    --right_fq reads_2.fq \</span><br><span class="line">    --output_dir star_fusion_outdir \</span><br><span class="line">    --no_remove_dups</span><br></pre></td></tr></table></figure><h3 id="从-STAR-产生-Bam-文件开始"><a href="#从-STAR-产生-Bam-文件开始" class="headerlink" title="从 STAR 产生 Bam 文件开始"></a>从 STAR 产生 Bam 文件开始</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">STAR --genomeDir $&#123;star_index_dir&#125; \</span><br><span class="line">    --readFilesIn $&#123;left_fq_filename&#125; $&#123;right_fq_filename&#125; \</span><br><span class="line">    --twopassMode Basic \</span><br><span class="line">    --outReadsUnmapped None \</span><br><span class="line">    --chimSegmentMin 12 \</span><br><span class="line">    --chimJunctionOverhangMin 12 \</span><br><span class="line">    --alignSJDBoverhangMin 10 \</span><br><span class="line">    --alignMatesGapMax 100000 \</span><br><span class="line">    --alignIntronMax 100000 \</span><br><span class="line">    --chimSegmentReadGapMax 3 \</span><br><span class="line">    --alignSJstitchMismatchNmax 5 -1 5 5 \</span><br><span class="line">    --runThreadN $&#123;THREAD_COUNT&#125; \</span><br><span class="line">    --outSAMstrandField intronMotif</span><br><span class="line"></span><br><span class="line">STAR-Fusion --genome_lib_dir /path/to/your/CTAT_resource_lib \</span><br><span class="line">             -J Chimeric.out.junction \</span><br><span class="line">             --output_dir star_fusion_outdir</span><br></pre></td></tr></table></figure><h2 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h2><p>STAR 速度还是那么让人惊喜，6m reads不到半小时。 融合结果<code>star-fusion.fusion_predictions.abridged.tsv</code></p><blockquote><p><strong>FusionName</strong>,<br><strong>JunctionReadCount</strong>, split align到融合点的序列片段数<br><strong>SpanningFragCount</strong>, 双端reads跨越融合点的序列片段数<br><strong>SpliceType</strong>, 断点是否在注释文件存在<br><strong>LeftGene</strong>,<br><strong>LeftBreakpoint</strong>,<br><strong>RightGene</strong>,<br><strong>RightBreakpoint</strong>,<br><strong>LargeAnchorSupport</strong>,<br><strong>FFPM</strong>, fusion fragments per million total reads<br><strong>LeftBreakDinuc</strong>,<br><strong>LeftBreakEntropy</strong>,<br><strong>RightBreakDinuc</strong>,<br><strong>RightBreakEntropy</strong>,<br><strong>annots</strong>,</p></blockquote><h2 id="结果比较"><a href="#结果比较" class="headerlink" title="结果比较"></a>结果比较</h2><p>真是一个悲伤的故事，根据官网给的两种运行方式，结果差别这么大。查看 STAR-Fusion 脚本，使用的 mapping 参数差异有点大啊，哪一个比较合理呢（一个新坑）？？？</p><p><img src="/2018/201805_STARFusion/./images/2018/star_fusion.results.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FusionGene </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 trimmomatic 进行数据质控</title>
      <link href="/2018/201805_trimmomatic/"/>
      <url>/2018/201805_trimmomatic/</url>
      <content type="html"><![CDATA[<p>trimmomatic 使用 java 编写，免安装多平台运行，同时运行速度非常快。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> paired end </span><br><span class="line">java -jar trimmomatic-0.32.jar PE -threads 8 -phred33 \</span><br><span class="line">    sample_R1.fastq.gz sample_R2.fastq.gz \</span><br><span class="line">    sample_R1_paired.fastq.gz sample_R1_unpaired.fastq.gz \</span><br><span class="line">    sample_R2_paired.fastq.gz sample_R2_unpaired.fastq.gz \</span><br><span class="line">    ILLUMINACLIP:TruSeq3-PE.fa:2:30:10 SLIDINGWINDOW:4:15 MINLEN:36</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> single end</span><br><span class="line">java -jar trimmomatic-0.32.jar PE -threads 8 -phred33 \</span><br><span class="line">    sample.fastq.gz sample_clean.fastq.gz \</span><br><span class="line">    ILLUMINACLIP:TruSeq3-PE.fa:2:30:10 SLIDINGWINDOW:4:15 MINLEN:36</span><br></pre></td></tr></table></figure><p>参数选择<br><strong>PE/SE</strong></p><blockquote><p>设定对 Paired-End 或 Single-End 的 reads 进行处理，其输入和输出参数稍有不一样</p></blockquote><p><strong>threads</strong></p><blockquote><p>设置多线程运行数</p></blockquote><p><strong>phred33/phred64</strong></p><blockquote><p>设置碱基的质量格式，可选 phred64</p></blockquote><p><strong>ILLUMINACLIP</strong>:<fastawithadaptersetc>:<seed mismatches="">:<palindrome clip="" threshold="">:<simple clip="" threshold="">:<minadapterlength>:<keepbothreads> </keepbothreads></minadapterlength></simple></palindrome></seed></fastawithadaptersetc></p><blockquote><p>切除 adapter 序列。参数后分别接 adapter 序列的 fasta 文件，允许的最大 mismatch 数， palindrome 模式下匹配碱基数阈值： simple 模式下的匹配碱基数阈值</p><p><em>minAdapterLength</em>：只对 PE 测序的 palindrome clip 模式有效，指定 palindrome 模式下可以切除的接头序列最短长度，由于历史的原因，默认值是 8，但实际上 palindrome 模式可以切除短至 1bp 的接头污染，所以可以设置为 1 。<br><em>keepBothReads</em>：只对 PE 测序的 palindrome clip 模式有效，这个参数很重要，在上图中 D 模式下， R1 和 R2 在去除了接头序列之后剩余的部分是完全反向互补的，默认参数 false，意味着整条去除与 R1 完全反向互补的 R2，当做重复去除掉，但在有些情况下，例如需要用到 paired reads 的 bowtie2 流程，就要将这个参数改为 true，否则会损失一部分 paired reads。</p></blockquote><p><strong>SLIDINGWINDOW</strong></p><blockquote><p>从 reads 首端（ 5’端）开始进行滑动，当滑动位点周围一段序列(window)的平均碱基低于阈值，则从该处进行切除。 Windows 的 size 是 4 bp， 若其平均碱基质量小于15，则切除</p></blockquote><p>MAXINFO：<br><strong>LEADING/TRAILING&gt;</strong></p><blockquote><p>切除 reads 首端（ 5’端） / reads 末端（ 3’端）碱基质量小于指定值的碱基</p></blockquote><p><strong>CROP/HEADCROP</strong></p><blockquote><p>从 reads 末端（ 3’端）/reads 首端（ 5’端）切除碱基到指定长度</p></blockquote><p><strong>MINLEN</strong></p><blockquote><p>抛弃低于指定长度的 reads</p></blockquote><p><strong>TOPHRED33/TOPHRED64</strong></p><blockquote><p>转换碱基质量格式，Illumina HiSeq 2000质量系统为phred-64，可用该参数转换到phred-33</p></blockquote>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>VCF 注释 —— SnpEff</title>
      <link href="/2018/201805_snpEff/"/>
      <url>/2018/201805_snpEff/</url>
      <content type="html"><![CDATA[<p>日常工作之读文档，了解参数改变、新方法功能，对已有流程进行修改。</p><p>各种文档看一边遍一遍，使用需要又一次看 SnpEff （<a href="http://snpeff.sourceforge.net/index.html" target="_blank" rel="noopener">http://snpeff.sourceforge.net/index.html</a> ），进行一些整理如下，不过还是建议<a href="http://snpeff.sourceforge.net/SnpEff_manual.html" target="_blank" rel="noopener">原文</a>，鬼知道我会在哪里写错理解错。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ol><li><p>annotation</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java -jar snpEff.jar eff genome input.vcf &gt;output.vcf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -hgvs, 默认开启，使用 HGVS 变异描述语法对蛋白替换进行描述</span><br><span class="line"><span class="meta">#</span> -fi, 提供bed文件，只对bed区域内位点进行注释</span><br><span class="line"><span class="meta">#</span> -no-downstream, -no-intergenic, -no-intron, -no-upstream, -no-utr, -no [effectType], 参数还可对根据注释类型对注释进行初过滤</span><br><span class="line"><span class="meta">#</span> -canon, 只使用基因对应最长转录本（作为权威转录本）进行注释；参数-canonList可以自行提供基因权威转录本，格式为“GeneID    transcript_ID”</span><br><span class="line"><span class="meta">#</span> -noStats, 不输出注释统计信息</span><br><span class="line"><span class="meta">#</span> -v, 话痨模式，输出各种运行信息</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>database</p><p>人、小鼠等物种都有已经 build 的数据库，可以直接下载，链接：<a href="https://sourceforge.net/projects/snpeff/files/databases/v4_3/" target="_blank" rel="noopener">https://sourceforge.net/projects/snpeff/files/databases/v4_3/</a>，注释选择基因组版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -jar snpEff.jar databases    # 查看可用数据库</span><br><span class="line">java -jar snpEff.jar download -v GRCh37.75    # 下载数据库 GRCh37.75</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Q, 使用执行程序下载数据库时容易断，一般建议手动下载，或者wget等其他方式</span><br></pre></td></tr></table></figure><p>软件还提供了自行构建数据库，详细用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加配置信息</span><br><span class="line">echo 'GRCh37.70.genome : Human ' &gt;&gt;~/snpEff/snpEff.config</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Create directoy for this new genome</span><br><span class="line">mkdir -p ~/snpEff/data/GRCh37.70 &amp;&amp; cd ~/snpEff/data/GRCh37.70</span><br><span class="line"><span class="meta">#</span> Get annotation files</span><br><span class="line">wget -c -O genes.gtf.gz ftp://ftp.ensembl.org/pub/release-70/gtf/homo_sapiens/Homo_sapiens.GRCh37.70.gtf.gz</span><br><span class="line"><span class="meta">#</span> Get the genome</span><br><span class="line">wget -c -O sequences.fa.gz ftp://ftp.ensembl.org/pub/release-70/fasta/homo_sapiens/dna/Homo_sapiens.GRCh37.70.dna.toplevel.fa.gz</span><br><span class="line"><span class="meta">#</span> Optional, Download CDSs</span><br><span class="line">wget -c -O cds.fa.gz ftp://ftp.ensembl.org/pub/release-70/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh37.70.cdna.all.fa.gz</span><br><span class="line"><span class="meta">#</span> Optional, Download proteins</span><br><span class="line">wget -c -O protein.fa.gz ftp://ftp.ensembl.org/pub/release-70/fasta/homo_sapiens/pep/Homo_sapiens.GRCh37.70.pep.all.fa.gz</span><br><span class="line"><span class="meta">#</span> Optional, Download regulatory annotations</span><br><span class="line">wget -c -O regulation.gff.gz ftp://ftp.ensembl.org/pub/release-70/regulation/homo_sapiens/AnnotatedFeatures.gff.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Building a database from GFF files</span><br><span class="line">cd ~/snpEff &amp;&amp; java -jar snpEff.jar build -gff3 -v GRCh37.70</span><br><span class="line"><span class="meta">#</span> rm -r ~/snpEff/data/GRCh37.70</span><br></pre></td></tr></table></figure><p>此外，snpEff 构建数据库还支持 RefSeq, GenBank 等多种数据输入格式，具体用法查看原文档。</p><p><strong>注意物种 codon 选择</strong>，codon 可以在 <a href="https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</a> 中查看，codon可以在<code>~/snpEff/snpEff.config</code>文件中设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置特异 codon</span><br><span class="line">codon.Invertebrate_Mitochondrial:  TTT/F, TTC/F, TAC/Y, TAA/*, ATG/M+, ATG/M+, ACT/T, ...</span><br><span class="line"># 物种选择恰当的 codontable</span><br><span class="line">dm3.M.codonTable : Invertebrate_Mitochondrial    # the chromosome &apos;M&apos; from fly genome (dm3) uses Invertebrate_Mitochondrial codon table</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>dump</p><p>从数据库中提取出注释信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar snpEff.jar dump -v -bed GRCh37.70 &gt; GRCh37.70.bed</span><br><span class="line"><span class="meta">#</span> [-bed |-txt ] 设置数据格式</span><br><span class="line"><span class="meta">#</span> [-0 |-1 ] 设置坐标系统，0-based 或者 1-based</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h3 id="注释结果"><a href="#注释结果" class="headerlink" title="注释结果"></a>注释结果</h3><p><img src="/2018/201805_snpEff/./images/2018/snpEff.png" alt=""></p><p>可以看到注释信息被添加到了 VCF 中每个变异 INFO 信息中，以 ANN= 特征开始，详细的注释说明可查看<a href="./appendix/snpEff.pdf">官方文档</a> <a href="http://snpeff.sourceforge.net/VCFannotationformat_v1.0.pdf" target="_blank" rel="noopener">http://snpeff.sourceforge.net/VCFannotationformat_v1.0.pdf</a>。因为基因多个转录本、相互重叠基因等原因，可以看到变异位点被多次注释，需根据实际需求进行筛选。</p>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>卸载一个假忙的硬盘</title>
      <link href="/2017/201709_umount/"/>
      <url>/2017/201709_umount/</url>
      <content type="html"><![CDATA[<ol><li><p><code>df -h</code>查看卸载硬盘信息</p></li><li><p><code>umount /dev/sdf</code>，停止使用的硬盘假装忙碌状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount: /mnt/usbhd2: device is busy.</span><br><span class="line">        (In some cases useful info about processes that use</span><br><span class="line">         the device is found by lsof(8) or fuser(1))</span><br></pre></td></tr></table></figure></li><li><p><code>fuser /dev/sdf</code>，查看占用硬盘的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/sdf:         106657c</span><br></pre></td></tr></table></figure></li><li><p><code>kill -9 106657</code></p></li><li><p>重新执行<code>umount /dev/sdf</code></p></li></ol>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>shell 命令使用笔记</title>
      <link href="/2017/201709_ShellNote/"/>
      <url>/2017/201709_ShellNote/</url>
      <content type="html"><![CDATA[<ol><li><p><code>&amp;&amp;</code>，cmd1 &amp;&amp; cmd2</p><p>如果cmd1成功执行（返回0，注意设置中脚本执行返回值），那么执行cmd2</p><p>​</p></li><li><p><code>||</code>，cmd1 || cmd2</p><p>如果cmd1执行失败，那么执行cmd2</p><p>​</p></li><li><p><code>()</code>, <code>{}</code>组合逻辑控制</p><p>()组合来控制命令； {}组合控制子shell</p><p>​</p></li><li><p>条件判断</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ]; then</span><br><span class="line"><span class="meta">#</span> if test condition; then</span><br><span class="line">    echo 'yes'</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>使用[]判断条件时，[]和condition之间必须用空格分隔开</span><br><span class="line"><span class="meta">#</span> -d        判断是不是文件夹</span><br><span class="line"><span class="meta">#</span> -f        判断是不是文件</span><br><span class="line"><span class="meta">#</span> -L        判断是不是链接</span><br><span class="line"><span class="meta">#</span> -s        判断文件是否存在且非空</span><br><span class="line"><span class="meta">#</span> -r        判断文件是否可读</span><br><span class="line"><span class="meta">#</span> -w        判断文件是否可写</span><br><span class="line"><span class="meta">#</span> -x        判断文件是否可执行</span><br><span class="line"><span class="meta">#</span> -z        判断是否空字符串</span><br><span class="line"><span class="meta">#</span> -n        判断是否非空字符串</span><br><span class="line"><span class="meta">#</span> =         判断字符串是否相等</span><br><span class="line"><span class="meta">#</span> !=        判断字符串是否不等</span><br><span class="line"><span class="meta">#</span> -eq       判断数值是否相等</span><br><span class="line"><span class="meta">#</span> -ne       判断数值是否不等</span><br><span class="line"><span class="meta">#</span> -gt       第一个数大于第二个数</span><br><span class="line"><span class="meta">#</span> -ge       第一个数大于等于第二个数</span><br><span class="line"><span class="meta">#</span> -lt       第一个数小于第二个数</span><br><span class="line"><span class="meta">#</span> -le       第一个数小于等于第二个数</span><br><span class="line"><span class="meta">#</span> -a        逻辑与</span><br><span class="line"><span class="meta">#</span> -o        逻辑或</span><br><span class="line"><span class="meta">#</span> !         逻辑否</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>推出状态</p><p><code>exit n</code>，其中n表示数字，0表示脚本执行成功无错误，1表示执行失败某处有错误</p><blockquote><p>可以使用 <strong>$?</strong> 获得最后执行命令推出状态</p></blockquote><p>​</p></li><li><p>shell脚本</p><ul><li><p>[ ] <strong>$#</strong> 获取脚本输出参数长度</p></li><li><p>[ ] <strong>$@</strong> 获取脚本所有参数</p></li></ul></li></ol><ol start="7"><li><p>循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in `ls `</span><br><span class="line">    do</span><br><span class="line">        echo 'yes'</span><br><span class="line">    done</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>序列生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq 3    # 1 2 3</span><br><span class="line">seq 3 5    # 3 4 5</span><br><span class="line">seq 5 2 10    # 5 7 9</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>随机数生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo $RANDOM</span><br><span class="line"><span class="meta">#</span> RANDOM是bash的一个内建函数，会返回一个[0, 32676]内的整数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成一定范围内的随机数</span><br><span class="line">beg=5</span><br><span class="line">end=15</span><br><span class="line">echo $((RANDOM % ($end - $beg) + $beg))</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>shell 数学计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $((9-4))    # 5</span><br><span class="line">echo $((9/4))    # 2</span><br><span class="line">echo $((9/-4))    # -2</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>提交测序数据到 SRA</title>
      <link href="/2017/201709_submitDataToSRA/"/>
      <url>/2017/201709_submitDataToSRA/</url>
      <content type="html"><![CDATA[<p>九月一号开学了，暑假作业写完了没有？但是跟我并没有关系，不开学，没作业，但是好多事情啊，，，最近提交了一些数据到SRA，每次过程总是那么曲折离奇，对一些遇到的问题进行整理填坑吧。</p><p>简单说，申请<strong>BioProject</strong>，申请<strong>BioSample</strong>，填写<strong>SRA_metadata</strong>，上传数据，虽然过程清晰，坑还没填完，仍在邮件NCBI，过程供参考。</p><h2 id="1-BioProject"><a href="#1-BioProject" class="headerlink" title="1. BioProject"></a>1. <a href="https://submit.ncbi.nlm.nih.gov/subs/bioproject/" target="_blank" rel="noopener">BioProject</a></h2><p>申请一个项目编号，填写submitter 信息，选择项目类型（Raw sequence reads），物种名称，释放时间，项目描述，BioSample和文章信息（跳过，跳过，，），核对提交</p><h2 id="2-BioSample"><a href="#2-BioSample" class="headerlink" title="2. BioSample"></a>2. <a href="https://submit.ncbi.nlm.nih.gov/subs/biosample/" target="_blank" rel="noopener">BioSample</a></h2><p>申请一个样品编号，submitter 信息，释放时间，样品类型，<strong>填写样品属性表格</strong>，核对提交</p><h2 id="3-SRA"><a href="#3-SRA" class="headerlink" title="3. SRA"></a>3. <a href="https://submit.ncbi.nlm.nih.gov/subs/sra/" target="_blank" rel="noopener">SRA</a></h2><p>主要就填写<strong>SRA_metadata</strong>，测序平台，文库类型等等，选择批量提交，填写表格注意看要求啊，除了样品名称、登录号等信息，其他属性组合每行也要是唯一的。</p><h2 id="4-submit-data"><a href="#4-submit-data" class="headerlink" title="4. submit data"></a>4. submit data</h2><p>看数据大小，选择合适上传方法吧，小于2G用aspera浏览器插件，大数据选择ftp或者aspera命令行。这几次都用了aspera cmd上传，霸占几乎全部网速，很快上传好</p><p>具体命令为：<code>ascp -i &lt;path/to/key_file&gt; -QT -l100m -k1 -d &lt;path/to/folder/containing files&gt; subasp@upload.ncbi.nlm.nih.gov:uploads/XXX@xxx.com_g3O1FgOE</code>， 其中key必须是全路径，-d接包括原始数据的文件夹（<strong>不再包含其他文件夹</strong>），<a href="mailto:XXX@xxx.com" target="_blank" rel="noopener">XXX@xxx.com</a>为注册账号邮箱</p><p>上传结束后，SRA中选择上传数据文件夹，，，</p><blockquote><p><em>好了，装逼结束，文件没仔细检查，传了两不完整的fastq，发邮件给ncbi沟通呢，md5值也还没有用到，不知什么情况，，，too young, too naive…</em></p></blockquote>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python class 实现 fasta 文件解析</title>
      <link href="/2017/201708_object/"/>
      <url>/2017/201708_object/</url>
      <content type="html"><![CDATA[<p>没有对象怎么办（object）？？？当然是new一个啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sequence</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 使用__init__对Sequence进行初始化，Sequence对象具有三个属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, seq, descr=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.seq = seq</span><br><span class="line">        self.descr = descr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给Sequence对象定义一个反向互补方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_complement</span><span class="params">(self)</span>:</span></span><br><span class="line">        RC = &#123;<span class="string">'A'</span>:<span class="string">'T'</span>,<span class="string">'T'</span>:<span class="string">'A'</span>,<span class="string">'C'</span>:<span class="string">'G'</span>,<span class="string">'G'</span>:<span class="string">'C'</span>,<span class="string">'N'</span>:<span class="string">'N'</span>,</span><br><span class="line">              <span class="string">'a'</span>:<span class="string">'t'</span>,<span class="string">'t'</span>:<span class="string">'a'</span>,<span class="string">'c'</span>:<span class="string">'g'</span>,<span class="string">'g'</span>:<span class="string">'c'</span>,<span class="string">'n'</span>:<span class="string">'n'</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> Sequence(self.name, <span class="string">''</span>.join([RC[i] <span class="keyword">for</span> i <span class="keyword">in</span> self.seq[::<span class="number">-1</span>]]), self.descr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义输出到文件的方法，接受文件句柄输入</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_to_fasta_file</span><span class="params">(self, file_handle)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_SeqFormat</span><span class="params">(seq, chara=<span class="number">80</span>)</span>:</span></span><br><span class="line">            tmp = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(seq),chara):</span><br><span class="line">                tmp += (seq[i:(i+chara)]+<span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        file_handle.write(<span class="string">'&gt;&#123;&#125; &#123;&#125;\n'</span>.format(self.name, self.descr))</span><br><span class="line">        file_handle.write(<span class="string">'&#123;&#125;'</span>.format(_SeqFormat(self.seq)))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastaReader</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fastafile)</span>:</span></span><br><span class="line">        self.fasta = fastafile</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用__iter__方法实现对fasta文件的循环解析，其中用到yeild构造了生成器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.fasta) <span class="keyword">as</span> f:</span><br><span class="line">            seq = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith( <span class="string">"&gt;"</span> ):</span><br><span class="line">                    <span class="keyword">if</span> seq:</span><br><span class="line">                        <span class="keyword">yield</span> Sequence( name, seq, descr )</span><br><span class="line">                    name, sep, descr = line[<span class="number">1</span>:<span class="number">-1</span>].partition(<span class="string">' '</span>)</span><br><span class="line">                    seq = <span class="string">""</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">assert</span> seq <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>, <span class="string">"FASTA file does not start with '&gt;'."</span></span><br><span class="line">                    seq += line[:<span class="number">-1</span>].encode()</span><br><span class="line">        <span class="keyword">if</span> seq <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> Sequence( name, seq, descr )</span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> FastaReader(<span class="string">'ref.fa'</span>):</span><br><span class="line">    <span class="comment"># 使用</span></span><br><span class="line">    i.write_to_fasta_file(file_handle)</span><br><span class="line">    i.seq</span><br><span class="line">    i.name</span><br><span class="line">    i.descr</span><br></pre></td></tr></table></figure><p>懒癌发作了，就这，，，</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fasta </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器挂载 4T 硬盘</title>
      <link href="/2017/201707_mountHardDisk/"/>
      <url>/2017/201707_mountHardDisk/</url>
      <content type="html"><![CDATA[<p>因为一些我并不理解的原因，服务器不能正确识别4T的NTFS移动硬盘，需要对其格式化成ext4格式，就我的一些操作记录。</p><ol><li><p><code>fdisk -l</code>，查看硬盘分配的硬件编号</p><p><img src="/2017/201707_mountHardDisk/./images/2017/fdisk.png" alt=""></p></li><li><p><code>parted /dev/sdg</code>，对使用parted工具对硬盘进行分区</p><ul><li><p><code>mklable gpt</code>，把磁盘格式化为 gpt分区表</p></li><li><p><code>mkpart primary 0 4000G</code>，创建一个主分区，起始位置-结束位置</p></li><li><p><code>mkpart extended 2000G 4000G</code>，可选，创建一个扩展分区</p></li><li><p><code>print</code>，打印出当前设备的信息</p></li><li><p><code>quit</code>，推出parted</p></li></ul><p><img src="/2017/201707_mountHardDisk/./images/2017/linux_parted.png" alt=""></p></li><li><p><code>mkfs.ext4 /dev/sdg1</code>，对硬盘进行格式化，如果存在多个分区，每个分区都需要进行格式化</p><p><img src="/2017/201707_mountHardDisk/./images/2017/mkfs.ext4.png" alt=""></p></li><li><p><code>mount /dev/sdg1 /mnt/usbmount1</code>，挂载硬盘到服务器</p></li><li><p><code>umount /dev/sdg1</code>，硬盘卸载</p></li></ol>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一次诡异的 python 错误排查</title>
      <link href="/2017/201707_VariableName/"/>
      <url>/2017/201707_VariableName/</url>
      <content type="html"><![CDATA[<p>输入表格示例：</p><table><thead><tr><th>library</th><th>reads_num</th><th>reads_len</th><th>bases_num</th><th>GC</th><th>avgQ</th><th>Q20</th><th>Q30</th></tr></thead><tbody><tr><td>A-Ctrl</td><td>46,875,170</td><td>150.0</td><td>7.00 Gb</td><td>49.90%</td><td>36.6</td><td>93.24%</td><td>85.97%</td></tr><tr><td>B-Ctrl</td><td>154,351,882</td><td>150.0</td><td>23.00 Gb</td><td>45.40%</td><td>36.9</td><td>93.80%</td><td>86.93%</td></tr><tr><td>C-Ctrl</td><td>58,126,912</td><td>150.0</td><td>8.00 Gb</td><td>60.05%</td><td>36.05</td><td>92.19%</td><td>83.96%</td></tr><tr><td>D-Ctrl</td><td>143,761,494</td><td>150.0</td><td>21.00 Gb</td><td>42.00%</td><td>37.25</td><td>94.46%</td><td>88.15%</td></tr></tbody></table><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误的结果</span></span><br><span class="line">table = open(<span class="string">'qc.stat'</span>, <span class="string">'r'</span>)</span><br><span class="line">header = [[],] * len(table.readline().strip().split(<span class="string">'\t'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> enumerate(i.strip().split(<span class="string">'\t'</span>)):</span><br><span class="line">        header[x].append(y)</span><br><span class="line">header</span><br><span class="line"><span class="comment"># table.close()</span></span><br></pre></td></tr></table></figure><h3 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h3><pre><code>[[&apos;A&apos;,  &apos;46,875,170&apos;,  &apos;150.0&apos;,  &apos;7.00 Gb&apos;,  &apos;49.90%&apos;,  &apos;36.6&apos;,  &apos;93.24%&apos;,  &apos;85.97%&apos;,  &apos;B&apos;,  &apos;154,351,882&apos;,  &apos;150.0&apos;,  &apos;23.00 Gb&apos;,  &apos;45.40%&apos;,  &apos;36.9&apos;,  &apos;93.80%&apos;,  &apos;86.93%&apos;,  &apos;C&apos;,  &apos;58,126,912&apos;,  &apos;150.0&apos;,  &apos;8.00 Gb&apos;,  &apos;60.05%&apos;,  &apos;36.05&apos;,  &apos;92.19%&apos;,  &apos;83.96%&apos;,  &apos;D&apos;,  &apos;143,761,494&apos;,  &apos;150.0&apos;,  &apos;21.00 Gb&apos;,  &apos;42.00%&apos;,  &apos;37.25&apos;,  &apos;94.46%&apos;,  &apos;88.15%&apos;], [&apos;A&apos;,  &apos;46,875,170&apos;,  &apos;150.0&apos;,  &apos;7.00 Gb&apos;,  &apos;49.90%&apos;,  &apos;36.6&apos;,  &apos;93.24%&apos;,  &apos;85.97%&apos;,  &apos;B&apos;,  &apos;154,351,882&apos;,  &apos;150.0&apos;,  &apos;23.00 Gb&apos;,  &apos;45.40%&apos;,  &apos;36.9&apos;,  &apos;93.80%&apos;,  &apos;86.93%&apos;,  &apos;C&apos;,  &apos;58,126,912&apos;,  &apos;150.0&apos;,  &apos;8.00 Gb&apos;,  &apos;60.05%&apos;,  &apos;36.05&apos;,  &apos;92.19%&apos;,  &apos;83.96%&apos;,  &apos;D&apos;,  &apos;143,761,494&apos;,  &apos;150.0&apos;,  &apos;21.00 Gb&apos;,  &apos;42.00%&apos;,  &apos;37.25&apos;,  &apos;94.46%&apos;,  &apos;88.15%&apos;], ...]</code></pre><h2 id="正确解析"><a href="#正确解析" class="headerlink" title="正确解析"></a>正确解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确代码</span></span><br><span class="line">table = open(<span class="string">'qc.stat'</span>, <span class="string">'r'</span>)</span><br><span class="line">header = [[i,] <span class="keyword">for</span> i <span class="keyword">in</span> table.readline().strip().split(<span class="string">'\t'</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> enumerate(i.strip().split(<span class="string">'\t'</span>)):</span><br><span class="line">        header[x].append(y)</span><br><span class="line">header</span><br><span class="line"><span class="comment"># table.close()</span></span><br></pre></td></tr></table></figure><h3 id="结果输出-1"><a href="#结果输出-1" class="headerlink" title="结果输出"></a>结果输出</h3><pre><code>[[&apos;library&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;], [&apos;reads_num&apos;, &apos;46,875,170&apos;, &apos;154,351,882&apos;, &apos;58,126,912&apos;, &apos;143,761,494&apos;], [&apos;reads_len&apos;, &apos;150.0&apos;, &apos;150.0&apos;, &apos;150.0&apos;, &apos;150.0&apos;], [&apos;bases_num&apos;, &apos;7.00 Gb&apos;, &apos;23.00 Gb&apos;, &apos;8.00 Gb&apos;, &apos;21.00 Gb&apos;], [&apos;GC&apos;, &apos;49.90%&apos;, &apos;45.40%&apos;, &apos;60.05%&apos;, &apos;42.00%&apos;], [&apos;avgQ&apos;, &apos;36.6&apos;, &apos;36.9&apos;, &apos;36.05&apos;, &apos;37.25&apos;], [&apos;Q20&apos;, &apos;93.24%&apos;, &apos;93.80%&apos;, &apos;92.19%&apos;, &apos;94.46%&apos;], [&apos;Q30&apos;, &apos;85.97%&apos;, &apos;86.93%&apos;, &apos;83.96%&apos;, &apos;88.15%&apos;]]</code></pre><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误原因查找</span></span><br><span class="line"></span><br><span class="line">head = <span class="string">'#library\treads_num\treads_len\tbases_num\tGC\tavgQ\tQ20\tQ30'</span></span><br><span class="line"></span><br><span class="line">header = [[], ] * len(head.strip().split(<span class="string">'\t'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'error method...'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> header:</span><br><span class="line">    <span class="keyword">print</span> id(i)</span><br><span class="line"></span><br><span class="line">header = [[i,] <span class="keyword">for</span> i <span class="keyword">in</span> head.strip().split(<span class="string">'\t'</span>)]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nright method...'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> header:</span><br><span class="line">    <span class="keyword">print</span> id(i)</span><br></pre></td></tr></table></figure><pre><code>error method...44352372724435237272443523727244352372724435237272443523727244352372724435237272right method...44352369844435354904443531868844352374164435318040443531976844353184724435319624</code></pre><p><strong>python独特的变量命名方式</strong>：变量名（&gt;= 1个）指向储存数据物理地址，使用其中任何一个名称都可以对数据进行操作</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python 字典</title>
      <link href="/2017/201706_pythondict/"/>
      <url>/2017/201706_pythondict/</url>
      <content type="html"><![CDATA[<p>字典也是哈希表，键(key)必须是唯一的可哈希对象，但值(value)则不必。python中键值间使用<strong>“:”</strong>分割，不同键值对间使用<strong>“,”</strong>分割，整个字典包括在<strong>“{}”</strong>中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化定义</span></span><br><span class="line">seq = &#123;&#125;    <span class="comment">#seq = dict()</span></span><br><span class="line">seq = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="设置字典默认值"><a href="#设置字典默认值" class="headerlink" title="设置字典默认值"></a>设置字典默认值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key不存在时，返回自定义value</span></span><br><span class="line">seq.get(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">#key不存在时，设置key对应键值为list；key存在时返回seq[key]</span></span><br><span class="line">seq.setdefault(key,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置默认字典，读取seq[key]时进行初始化</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">seq = defaultdict(list)</span><br></pre></td></tr></table></figure><ul><li><p>树结构</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">()</span>:</span> <span class="keyword">return</span> defaultdict(tree)</span><br><span class="line"></span><br><span class="line">users = tree()</span><br><span class="line">users[<span class="string">'codingpy'</span>][<span class="string">'username'</span>] = <span class="string">'earlgrey'</span></span><br><span class="line"><span class="comment">#甚至还能不赋值</span></span><br><span class="line">users[<span class="string">'Python'</span>][<span class="string">'Standard Library'</span>][<span class="string">'os'</span>]</span><br></pre></td></tr></table></figure></li></ul><h2 id="计算list中某元素出现次数"><a href="#计算list中某元素出现次数" class="headerlink" title="计算list中某元素出现次数"></a>计算list中某元素出现次数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">list.count(<span class="string">'X'</span>)    <span class="comment"># int</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">Counter(list)[<span class="string">'X'</span>]    <span class="comment"># dict['X'], int</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux 命令 —— find</title>
      <link href="/2017/201705_linuxfind/"/>
      <url>/2017/201705_linuxfind/</url>
      <content type="html"><![CDATA[<p>find，Linux常用文件搜索命令简要整理</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>find基本用法如：<code>find [path] &lt;search regular&gt; [action]</code></p><ul><li>可选参数path，支持空格分隔的多路径查找，默认为当前路径</li><li>可选参数action<ul><li>-print，匹配文件输出到stdout，默认</li><li>-exec，对find匹配到的文件执行该参数所给出的shell命令，格式为<strong>command { } \;</strong>，其中{}表示匹配文件</li><li>-ok，于-exec类似，执行前给出提示是否执行</li></ul></li></ul><ol><li><p>文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find [path] -name &lt;name&gt;</span><br><span class="line">find [path] -iname &lt;name&gt;    #不区分大小写</span><br><span class="line"><span class="meta">#</span> 其中&lt;name&gt;支持通配符，一般使用时建议增加单引号</span><br></pre></td></tr></table></figure></li><li><p>文件类型，一般配合其他搜索参数一起使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find [path] -type [bdcplf]</span><br><span class="line"><span class="meta">#</span> 其中d表示目录，l表示链接，f表示文件</span><br></pre></td></tr></table></figure></li><li><p>文件大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -size 参数支持+-表示大于小于，ckMG表示数据单位</span><br><span class="line">find [path] -size +10M    #path下大于10M的文件</span><br><span class="line">find [path] -size -1G    #path下小于1G的文件</span><br></pre></td></tr></table></figure></li><li><p>时间戳</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [path] -mtime -n +m    #更改时间为m天前n天内的文件</span><br><span class="line">find [path] -atime -n +m    #访问时间</span><br><span class="line">find [path] -ctime -n +m    #创建时间</span><br><span class="line"><span class="meta">#</span> mtime参数后数字表示天， mmin参数后数字表示分钟</span><br></pre></td></tr></table></figure></li><li><p>文件属主</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [path] -user &lt;user_name&gt;    #path下属主为user_name的文件</span><br><span class="line">find [path] -group &lt;group_name&gt;    #path下组名为group_name的文件</span><br><span class="line">find [path] -nouser    #用户ID不存在的文件</span><br><span class="line">find [path] -nogroup    #组ID不存在的文件</span><br></pre></td></tr></table></figure></li><li><p>文件权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [path] -perm 755    #权限设置为755的文件</span><br><span class="line">find [path] -perm -u=r    #文件属主有读权限的目录或文件</span><br><span class="line">find [path] -perm -g=r    #用户组有读权限的目录或文件</span><br><span class="line">find [path] -perm -o=r    #其它用户有读权限的目录或文件</span><br></pre></td></tr></table></figure></li><li><p>其他搜索参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [path] &lt;search_regular&gt; [option]</span><br><span class="line"><span class="meta">#</span> -follow 追踪链接文件</span><br><span class="line"><span class="meta">#</span> -mount 不跨越文件系统mount点</span><br><span class="line"><span class="meta">#</span> -empty 空文件</span><br></pre></td></tr></table></figure></li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ol><li><p>多筛选条件组合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [path] -name '*R' -a -mtime -1    #修改时间一天内的R脚本文件</span><br><span class="line"><span class="meta">#</span>-a | -and    # 同时满足</span><br><span class="line"><span class="meta">#</span>-o | -or    # 或</span><br><span class="line"><span class="meta">#</span>-not    # 条件取反</span><br></pre></td></tr></table></figure></li><li><p>几个例子，来自微博@linux命令行精选网</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find . ! -name &lt;NAME&gt; -delete    #用find删除文件时候排除特定文件</span><br><span class="line">find . -type l -xtype l    #查找失效的符号链接</span><br><span class="line">find . -iname '*.jpg' | sed 's/.*/&lt;img src="&amp;"&gt;/' &gt; gallery.html    #生成html 相册</span><br><span class="line">find . -size 0 -exec rm '&#123;&#125;' \;    #清理空文件</span><br><span class="line">find . -type d -exec mkdir -p $DESTDIR/&#123;&#125; \;    #复制一个目录的结构，忽略文件</span><br><span class="line">find . -type f -size +500M -exec ls -ls &#123;&#125; \; | sort -n    #找出所有大于500M的文件</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>fasta 序列解析</title>
      <link href="/2017/201705_parsefasta/"/>
      <url>/2017/201705_parsefasta/</url>
      <content type="html"><![CDATA[<p>fasta格式最常见，也最常用，也是分析中最简单的格式吧，以<code>&gt;</code>开始后续字符表示序列名称，<code>空格</code>后对序列进行描述（可能不存在），换行即为序列信息，可包括换行。下面是一个fasta格式序列实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;gi|187608668|ref|NM_001043364.2| Bombyx mori moricin (Mor), mRNA</span><br><span class="line">AAACCGCGCAGTTATTTAAAATATGAATATTTTAAAACTTTTCTTTGTTTTTA</span><br><span class="line">CAACGACAACTGTGTACTATTTTTTATATTTGGTTCGAAAAGTTGCATTATTA</span><br><span class="line">ACGATTTTAGAAAATAAAACTACTTTACTTTTACACG</span><br></pre></td></tr></table></figure><p>这个实例中序列名字为<strong>gi|187608668|ref|NM_001043364.2|</strong>，下面就直接贴上常用的fasta解析脚本：</p><h2 id="python手动解析"><a href="#python手动解析" class="headerlink" title="python手动解析"></a>python手动解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_fasta</span><span class="params">(fa)</span>:</span></span><br><span class="line">    seq = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> oepn(fa) <span class="keyword">as</span> fa:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> fa:</span><br><span class="line">            <span class="keyword">if</span> i.startswith(<span class="string">"&gt;"</span>):</span><br><span class="line">                name = i[<span class="number">1</span>:].partition(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span>:</span><br><span class="line">                seq[name] = seq.get(name, <span class="string">''</span>) + i.strip()</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure><h2 id="使用HTSeq模块"><a href="#使用HTSeq模块" class="headerlink" title="使用HTSeq模块"></a>使用HTSeq模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_fasta_by_HTSeq</span><span class="params">(fa)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> HTSeq</span><br><span class="line">    <span class="keyword">return</span> &#123;i.name:i.seq <span class="keyword">for</span> i <span class="keyword">in</span> HTSeq.FastaReader(fa)&#125;</span><br></pre></td></tr></table></figure><p>当然还能使用biopython进行解析，我不太常用这一模块，就不写了</p><h2 id="fasta输出格式化"><a href="#fasta输出格式化" class="headerlink" title="fasta输出格式化"></a>fasta输出格式化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_fasta</span><span class="params">(seq, len=<span class="number">60</span>)</span>:</span></span><br><span class="line">    tmp = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((len(seq)//len)+<span class="number">1</span>):</span><br><span class="line">        tmp += <span class="string">'&#123;&#125;\n'</span>.format(seq[(i*<span class="number">60</span>):((i+<span class="number">1</span>)*<span class="number">60</span>)])</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fasta </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RefSeq 数据库 GFF 格式转换</title>
      <link href="/2017/201705_RefSeqGFF2GTF/"/>
      <url>/2017/201705_RefSeqGFF2GTF/</url>
      <content type="html"><![CDATA[<p>最近一项目被RefSeq数据库中gff注释格式折磨死，流程总是不能正确识别，各种方法改了格式，勉强运行，后续步骤继续报错，想着以后肯定还有更多这种情况，自己对文件格式的理解，写了格式转换脚本。</p><p>GFF和GTF格式非常类似，都被用来基因结构注释，由9列表示不同意义的特征组成，多行共同注释一个基因的详细结构。然而两者又有很大差异，脚本处理起来也是不同。相比而言GTF处理起来简单些，第三列<code>feature</code>可能是<strong>gene, transcript, exon, CDS</strong>这少数几种情况，最重要的描述基因类型名称的第九列<code>attr</code>很统一，都会包括一般常用的<strong>gene_id, gene_biotype, transcript_id, transcript_biotype</strong>等特征。而GFF文件包括一个明确的层级关系，<strong>gene</strong>是<strong>transcript</strong>（存在mRNA，lncRNA，ncRNA，rRNA，tRNA等多种不同组织方式）的父节点，而<strong>transcript</strong>又是<strong>exon</strong>和<strong>CDS</strong>的父节点，特征层级不同也决定了第九列<code>attr</code>的注释信息不同，gene id, name等信息也是层次关系关联，文件处理较麻烦。</p><p>NCBI RefSeq数据库中GFF注释格式感觉更是复杂怪异，废话不多说，直接上代码，愚蠢方法手撕GFF</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GFF_parser</span><span class="params">(file)</span>:</span></span><br><span class="line">    openfile = gzip.open <span class="keyword">if</span> file.endswith(<span class="string">'gz'</span>) <span class="keyword">else</span> open</span><br><span class="line">    <span class="keyword">with</span> openfile(file) <span class="keyword">as</span> anno_file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> anno_file:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">'#'</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            seqname, source, feature, start, end, score, strand, \</span><br><span class="line">            frame, attributeStr = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">            attribute = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> attributeStr.split(<span class="string">';'</span>) <span class="keyword">if</span> i.strip() != <span class="string">''</span>]</span><br><span class="line">            attr = &#123;i.partition(<span class="string">'='</span>)[<span class="number">0</span>]:i.partition(<span class="string">'='</span>)[<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> attribute&#125;</span><br><span class="line">            <span class="keyword">yield</span> seqname, source, feature, int(start), int(end), score, strand, frame, attr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_gtf_line</span><span class="params">(chro, feature, start, end, strand, attr, \</span></span></span><br><span class="line"><span class="function"><span class="params">    source=None, score=None, frame=None)</span>:</span></span><br><span class="line">    source = source <span class="keyword">if</span> source <span class="keyword">else</span> <span class="string">'RefSeq'</span></span><br><span class="line">    score = score <span class="keyword">if</span> score <span class="keyword">else</span> <span class="string">'.'</span></span><br><span class="line">    frame = frame <span class="keyword">if</span> frame <span class="keyword">else</span> <span class="string">'.'</span></span><br><span class="line">    attrstr = <span class="string">''</span>.join([<span class="string">'&#123;&#125; "&#123;&#125;"; '</span>.format(i[<span class="number">0</span>], i[<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> sorted(attr.items())])</span><br><span class="line">    gtf_line = <span class="string">'&#123;chro&#125;\t&#123;source&#125;\t&#123;feature&#125;\t&#123;start&#125;\t&#123;end&#125;\t&#123;score&#125;\t\</span></span><br><span class="line"><span class="string">        &#123;strand&#125;\t&#123;frame&#125;\t&#123;attrstr&#125;'</span>.format(**locals())</span><br><span class="line">    <span class="keyword">return</span> gtf_line</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(gff, output)</span>:</span></span><br><span class="line">    gtf_out = open(output, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RefSeq数据库中GFF文件feature收集，或去除无意义项，或替换</span></span><br><span class="line">    skip = [<span class="string">'region'</span>, <span class="string">'miRNA'</span>, <span class="string">'cDNA_match'</span>, <span class="string">'repeat_region'</span>, <span class="string">'D_loop'</span>, \</span><br><span class="line">            <span class="string">'match'</span>, <span class="string">'origin_of_replication'</span>, <span class="string">'centromere'</span>, <span class="string">'sequence_feature'</span>]</span><br><span class="line">    transcript = [<span class="string">'mRNA'</span>, <span class="string">'lnc_RNA'</span>, <span class="string">'primary_transcript'</span>, <span class="string">'tRNA'</span>, <span class="string">'rRNA'</span>, \</span><br><span class="line">            <span class="string">'C_gene_segment'</span>, <span class="string">'V_gene_segment'</span>, <span class="string">'SRP_RNA'</span>, <span class="string">'ncRNA'</span>, <span class="string">'transcript'</span>]</span><br><span class="line">    biotype = [<span class="string">'lnc_RNA'</span>, <span class="string">'tRNA'</span>, <span class="string">'rRNA'</span>, <span class="string">'SRP_RNA'</span>]</span><br><span class="line"></span><br><span class="line">    order = []</span><br><span class="line">    gene_info = defaultdict(dict)</span><br><span class="line">    transcript_info = defaultdict(dict)</span><br><span class="line">    check_gene_name = &#123;&#125;    <span class="comment">#检查重复gene_name</span></span><br><span class="line">    check_transcript_name = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> GFF_parser(gff):</span><br><span class="line">        chro, source, feature, start, end, score, strand, frame, attr = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> feature <span class="keyword">in</span> skip:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> feature == <span class="string">'gene'</span>:</span><br><span class="line">            gene_id = attr[<span class="string">'ID'</span>]</span><br><span class="line">            gene_info[gene_id][<span class="string">'name'</span>] = attr[<span class="string">'Name'</span>]</span><br><span class="line">            gene_info[gene_id][<span class="string">'biotype'</span>] = attr[<span class="string">'gene_biotype'</span>]</span><br><span class="line">            check_gene_name[gene_id] = attr[<span class="string">'Name'</span>]</span><br><span class="line">        <span class="comment">#使用字典transcript_info储存转录本信息</span></span><br><span class="line">        <span class="keyword">elif</span> feature <span class="keyword">in</span> transcript:</span><br><span class="line">            transcript_id = attr[<span class="string">'ID'</span>]</span><br><span class="line">            gene_id = attr[<span class="string">'Parent'</span>] <span class="keyword">if</span> <span class="string">'Parent'</span> <span class="keyword">in</span> attr <span class="keyword">else</span> transcript_id</span><br><span class="line">            transcript_name = attr[<span class="string">'transcript_id'</span>] <span class="keyword">if</span> <span class="string">'transcript_id'</span> \</span><br><span class="line">                <span class="keyword">in</span> attr <span class="keyword">else</span> transcript_id</span><br><span class="line">            order.append(transcript_id)</span><br><span class="line">            transcript_info[transcript_id][<span class="string">'gtf_info'</span>] = [chro, start, end, strand]</span><br><span class="line">            transcript_info[transcript_id][<span class="string">'name'</span>] = transcript_name</span><br><span class="line">            transcript_info[transcript_id][<span class="string">'gene'</span>] = gene_id</span><br><span class="line">            <span class="comment"># 部分转录本不存在对应gene信息，直接关联转录类型</span></span><br><span class="line">            <span class="keyword">if</span> feature <span class="keyword">in</span> biotype:</span><br><span class="line">                transcript_info[transcript_id][<span class="string">'biotype'</span>] = feature</span><br><span class="line">            check_transcript_name[transcript_id] = transcript_name</span><br><span class="line">        <span class="keyword">elif</span> feature == <span class="string">'exon'</span>:</span><br><span class="line">            transcript_id = attr[<span class="string">'Parent'</span>]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                transcript_info[transcript_id][<span class="string">'exon'</span>][<span class="number">1</span>].append(start)</span><br><span class="line">                transcript_info[transcript_id][<span class="string">'exon'</span>][<span class="number">2</span>].append(end)</span><br><span class="line">            <span class="keyword">except</span> KeyError:</span><br><span class="line">                transcript_info[transcript_id][<span class="string">'exon'</span>] = [chro, [start,], \</span><br><span class="line">                    [end,], strand]</span><br><span class="line">        <span class="keyword">elif</span> feature == <span class="string">'CDS'</span>:</span><br><span class="line">            transcript_id = attr[<span class="string">'Parent'</span>]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                transcript_info[transcript_id][<span class="string">'CDS'</span>][<span class="number">1</span>].append(start)</span><br><span class="line">                transcript_info[transcript_id][<span class="string">'CDS'</span>][<span class="number">2</span>].append(end)</span><br><span class="line">                transcript_info[transcript_id][<span class="string">'CDS'</span>][<span class="number">4</span>].append(frame)</span><br><span class="line">            <span class="keyword">except</span> KeyError:</span><br><span class="line">                transcript_info[transcript_id][<span class="string">'CDS'</span>] = [chro, [start,], \</span><br><span class="line">                    [end,], strand, [frame,]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">'Warning: Annotation Feature "&#123;&#125;" is not collected, '</span>\</span><br><span class="line">                <span class="string">'Unknown error may occur.\n'</span>.format(feature))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查重复gene_name， transcript_names，进行替换</span></span><br><span class="line">    dup_name = <span class="keyword">lambda</span> list_in: set([i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> Counter(list_in).items() <span class="keyword">if</span> i[<span class="number">1</span>] &gt; <span class="number">1</span>])</span><br><span class="line">    gene_name = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> check_gene_name.items()]</span><br><span class="line">    dup_gene_name = dup_name(gene_name)</span><br><span class="line"></span><br><span class="line">    transcript_name = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> check_transcript_name.items()]</span><br><span class="line">    dup_transcript_name = dup_name(transcript_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出GTF文件，order控制输出顺序</span></span><br><span class="line">    <span class="keyword">for</span> transcript <span class="keyword">in</span> order:</span><br><span class="line">        attr = &#123;&#125;</span><br><span class="line">        gene_id = transcript_info[transcript][<span class="string">'gene'</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            gene_name = gene_info[gene_id][<span class="string">'name'</span>]</span><br><span class="line">            gene_name = gene_id <span class="keyword">if</span> gene_name <span class="keyword">in</span> dup_gene_name <span class="keyword">else</span> gene_name</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            gene_name = gene_id</span><br><span class="line">        attr[<span class="string">'gene_id'</span>] = gene_name</span><br><span class="line">        transcript_name = transcript_info[transcript][<span class="string">'name'</span>]</span><br><span class="line">        transcript_name = transcript <span class="keyword">if</span> transcript_name <span class="keyword">in</span> 、</span><br><span class="line">            dup_transcript_name <span class="keyword">else</span> transcript_name</span><br><span class="line">        attr[<span class="string">'transcript_id'</span>] = transcript_name</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            attr[<span class="string">'transcript_biotype'</span>] = transcript_info[transcript][<span class="string">'biotype'</span>]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            attr[<span class="string">'transcript_biotype'</span>] = gene_info[gene_id][<span class="string">'biotype'</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            attr[<span class="string">'gene_biotype'</span>] =  gene_info[gene_id][<span class="string">'biotype'</span>]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            attr[<span class="string">'gene_biotype'</span>] =  transcript_info[transcript][<span class="string">'biotype'</span>]</span><br><span class="line">        chro, start, end, strand = transcript_info[transcript][<span class="string">'gtf_info'</span>]</span><br><span class="line">        gtf_out.write(<span class="string">'&#123;&#125;\n'</span>.format(format_gtf_line(chro,<span class="string">'transcript'</span>,、</span><br><span class="line">            start,end,strand,attr)))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exon_feature = transcript_info[transcript][<span class="string">'exon'</span>]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            exon_feature = transcript_info[transcript][<span class="string">'CDS'</span>][:<span class="number">-1</span>]</span><br><span class="line">        chro, start, end, strand = exon_feature</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(start):</span><br><span class="line">            gtf_out.write(<span class="string">'&#123;&#125;\n'</span>.format(format_gtf_line(chro,<span class="string">'exon'</span>,、</span><br><span class="line">                start[i],end[i],strand,attr)))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cds_feature = transcript_info[transcript][<span class="string">'CDS'</span>]</span><br><span class="line">            chro, start, end, strand, frame = cds_feature</span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(start):</span><br><span class="line">                gtf_out.write(<span class="string">'&#123;&#125;\n'</span>.format(format_gtf_line(chro, <span class="string">'CDS'</span>, start[i], \</span><br><span class="line">                        end[i], strand, attr, frame=frame[i])))</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment">#部分注释信息不完善，多次使用try... except...输出替代的对应注释信息</span></span><br><span class="line">    gtf_out.close()</span><br></pre></td></tr></table></figure><p>GFF格式包括<strong>gene, transcript, exon(CDS)</strong>三个层级，其中<strong>transcript</strong>进行上下关联最为重要，这里脚本以<strong>transcript</strong>作为键值进行数据处理，另外脚本还有一个假设就是<strong>gene, transcript</strong>对应ID在文件中唯一。</p>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GFF </tag>
            
            <tag> GTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 科学计算 —— anaconda</title>
      <link href="/2017/201705_anaconda/"/>
      <url>/2017/201705_anaconda/</url>
      <content type="html"><![CDATA[<p>python大法好，但是坑爹的版本，坑爹的包管理，折腾死大把大把工作时间。anaconda实现了python2和python3和谐共存，同时conda更方便的进行包管理，支持win，linux，mac多系统平台。</p><p>还有一些小小的便利，anaconda已经提供了python科学计算常用包，numpy, pandas, matplotlib等等，python notebook也必然是有的，目前已更名为<code>jupyter notebook</code>，输出文档很方便进行交流展示。</p><p>清华大学TUNA镜像网站提供了anaconda安装包，<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/，不必被下载速度折磨死。" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/，不必被下载速度折磨死。</a></p><h2 id="anaconda安装"><a href="#anaconda安装" class="headerlink" title="anaconda安装"></a>anaconda安装</h2><p>和python一样，anaconda存在2和3两个版本，目前都更新到4.3.1版，但是，，，还有一个但是，选择安装哪一个版本并没有太大区别，可以方便的通过anaconda环境管理切换不同的python版本。</p><p>针对unix like用户，anaconda还有一个非常重要的特性，非root用户也能方便的进行安装(默认安装到<code>~/anaconda2/</code>)，添加<code>~/anaconda2/bin</code>到环境变量<code>$PATH</code>，而后即可享受anaconda。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建名为python3的环境，python版本为3.4，该命令仅安装python基本模块</span><br><span class="line">conda create --name python3 python=3.4</span><br><span class="line"><span class="meta">#</span>创建新环境，同时针对新环境安装anaconda</span><br><span class="line">conda create --name python3 python=3.4 anaconda</span><br><span class="line"><span class="meta">#</span>激活python3环境</span><br><span class="line">source activate python3</span><br><span class="line"><span class="meta">#</span>关闭环境</span><br><span class="line">source deactivate python3</span><br><span class="line"><span class="meta">#</span>删除环境</span><br><span class="line">conda remove --name python3 --all</span><br></pre></td></tr></table></figure><h2 id="conda安装包"><a href="#conda安装包" class="headerlink" title="conda安装包"></a>conda安装包</h2><p>conda于pip类似，对python包进行管理，还能管理python和conda本身</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>列出当前环境中已安装的包</span><br><span class="line">conda list    </span><br><span class="line"><span class="meta">#</span>搜索，安装，升级，删除指定特定的包</span><br><span class="line">conda [search|install|update|remove] package_name</span><br><span class="line"><span class="meta">#</span>可以使用-n参数，对指定特定环境中的包进行操作</span><br><span class="line">conda list -n env_name</span><br><span class="line"><span class="meta">#</span>升级python或者conda，升级python至当前大版本的最新版本</span><br><span class="line">conda update python</span><br></pre></td></tr></table></figure><h2 id="anaconda镜像设置"><a href="#anaconda镜像设置" class="headerlink" title="anaconda镜像设置"></a>anaconda镜像设置</h2><p>anaconda主机在国外，conda在线安装包速度慢到怀疑人生，这时绝壁选择使用国内镜像网站，首先将仓库镜像加入conda配置，具体命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加Anaconda的TUNA镜像</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"><span class="meta">#</span> 设置搜索时显示通道地址</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>或者直接编辑文件<code>~/.condarc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssl_verify: true</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br></pre></td></tr></table></figure><p>然后，你就可以尽情享受python编程的快乐，不被各种包折磨死</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 ggplot 绘制扩增子 rank abundance 曲线</title>
      <link href="/2017/201704_rankabundance/"/>
      <url>/2017/201704_rankabundance/</url>
      <content type="html"><![CDATA[<p>ggplot2实现微生物rank abundance绘图，另发现了<code>reshape2</code>能方便的进行dataframe格式整理，长表格，宽表格相互转换</p><p>具体代码实现如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(reshape2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># otu_table    抽平后的otu table，第一列为OTU编号，最后一列为tax注释</span></span><br><span class="line">otu_table &lt;- read.table(otu_table, sep=<span class="string">"\t"</span>, header=<span class="literal">TRUE</span>)</span><br><span class="line">otu_table &lt;- otu_table[,<span class="number">2</span>:(length(otu_table)-<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:length(otu_table))&#123;    <span class="comment"># 计算等级相对丰度</span></span><br><span class="line">  sample &lt;- otu_table[,i]</span><br><span class="line">  otu_table[,i]&lt;- rev(sort(sample/sum(sample)))</span><br><span class="line">&#125;</span><br><span class="line">rank_abundance &lt;- otu_table</span><br><span class="line">rank_abundance$rank &lt;- <span class="number">1</span>:dim(rank_abundance)[<span class="number">1</span>]    <span class="comment"># 添加等级</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 宽表格整理成长表格</span></span><br><span class="line">dat &lt;- melt(rank_abundance, id.vars = c(<span class="string">'rank'</span>), variable.name=<span class="string">'sample'</span>)</span><br><span class="line"><span class="comment"># 整合样品分组信息</span></span><br><span class="line">group &lt;- read.table(group, sep=<span class="string">'\t'</span>, col.names=c(<span class="string">'sample'</span>, <span class="string">'group'</span>))</span><br><span class="line">dat &lt;- merge(dat, group, by=c(<span class="string">'sample'</span>), all=<span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment"># 移除0值</span></span><br><span class="line">dat &lt;- dat[dat$value&gt;<span class="number">0</span>,]</span><br><span class="line"></span><br><span class="line">g &lt;- ggplot(dat, aes(rank, log10(dat$value), group=sample)) + </span><br><span class="line">  geom_step(aes(color=group)) + <span class="comment">#ylim(-4,0) + xlim(0,2000) + </span></span><br><span class="line">  labs(x=<span class="string">"Species Rank"</span>, y=<span class="string">"Relative Abundance"</span>) + </span><br><span class="line">  <span class="comment"># 设置y轴指示刻度，针对不同数据，可能需要调整</span></span><br><span class="line">  scale_y_continuous(breaks=c(-<span class="number">4</span>,-<span class="number">3</span>,-<span class="number">2</span>,-<span class="number">1</span>), labels=c(<span class="string">'1e-4'</span>,<span class="string">'1e-3'</span>,<span class="string">'1e-2'</span>,<span class="string">'1e-1'</span>)) + </span><br><span class="line">  <span class="comment"># 调整y轴指示刻度显示方法</span></span><br><span class="line">  theme(axis.text.y = element_text(angle=<span class="number">90</span>, hjust=<span class="number">0.5</span>, vjust=<span class="number">1</span>)) + </span><br><span class="line"></span><br><span class="line">ggsave(<span class="string">"rank_abundance.pdf"</span>)</span><br></pre></td></tr></table></figure><p>结果展示：</p><p><img src="/2017/201704_rankabundance/./images/2017/rank_abundance.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ggplot </tag>
            
            <tag> amplicon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 基本命令介绍</title>
      <link href="/2017/201703_linuxcmd/"/>
      <url>/2017/201703_linuxcmd/</url>
      <content type="html"><![CDATA[<h1 id="linux-登录"><a href="#linux-登录" class="headerlink" title="linux 登录"></a>linux 登录</h1><p>远程登录linux服务器具体原理呢，水平还不够，说不清，先简单粗暴上方法。一般采取<code>ssh</code>的方式远程登录，常用ssh客户端有<a href="http://www.netsarang.com/" target="_blank" rel="noopener">xshell</a>, <a href="http://www.putty.org/" target="_blank" rel="noopener">putty</a>，本地电脑与服务器间数据传输一般是ftp客户端的方式，可以使用<a href="http://www.netsarang.com/" target="_blank" rel="noopener">xftp</a>, <a href="https://filezilla-project.org/" target="_blank" rel="noopener">FileZilla</a>。</p><p>登录需要<strong>帐号</strong>，<strong>密码</strong>，<strong>主机地址</strong>(ip或可解析网址)，一般ssh登录端口选择<strong>22</strong>，ftp登录端口选择<strong>21</strong>。</p><h1 id="basic-command"><a href="#basic-command" class="headerlink" title="basic command"></a>basic command</h1><ol><li><p><code>ls</code>：列出当前路径（或特定路径）下的文件、文件夹</p><p>-l    先是完整信息，包括文件属主、时间、权限等信息</p><p>-a   列出包括隐藏文件在内的所有问价，linux下隐藏文件以<code>.</code>开头</p><p>-h    文件大小以人类友好的方式显示，直观结果为文件大小以k, m, g等代替bit</p><p>-t    安装文件修改时间进行排列</p></li><li><p><code>pwd</code>：显示当前所在路径</p></li><li><p><code>cd</code>：进入文件夹，后接相对路径或全路径</p></li><li><p><code>mv</code>：更名，移动文件</p></li><li><p><code>cp</code>：拷贝文件</p><p>-L    拷贝源文件为链接时，追踪拷贝原始文件</p><p>-r    针对文件夹拷贝，递归拷贝文件夹下所有子目录或文件</p></li><li><p><code>ln</code>：创建文件链接</p><p>-s    创建软链接，相比<code>ln</code>创建链接方式，<code>ln -s</code>创建链接不占用硬盘空间</p></li><li><p><code>mkdir</code>：创建文件夹</p><p>-p    递归创建多级文件夹，eg：<code>mkdir -p /path/to/a/b/c</code>，其中文件夹a原本不存在，创建a同时创建子目录b子目录c</p></li><li><p><code>rmdir</code>：删除空文件夹</p></li><li><p><code>rm</code>：删除文件或文件夹</p><p>-r    递归删除，通常用于删除非空文件夹</p><p>-f     强制删除，不显示提示消息</p></li></ol><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol><li><p><code>cat</code>, <code>zcat</code>：zcat支持打开压缩文件</p></li><li><p><code>head</code>, <code>tail</code>：显示文件前10（默认）行，后10行</p><p>-n  num     指定显示行数</p></li><li><p><code>more</code>, <code>less</code></p></li><li><p><code>paste</code>：横向合并两个文本</p></li><li><p><code>touch</code>：创建文件</p></li><li><p><code>cut</code>：</p><p>-f n-m    显示文件第n到m列</p><p>-d     设置分隔符，默认‘\t’</p></li><li><p><code>join</code></p></li><li><p><code>vim</code>：文本编辑器</p></li><li><p><code>wc</code></p><p>-l    统计文件行数</p></li></ol><h1 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h1><ol><li><p><code>tar</code>：文档打包，通过调用gzip或bzip2压缩</p><p>-c    打包，创建新的tar文件</p><p>-x    解包，从tar文件中提取文件</p><p>-f    tar包文件</p><p>-v    显示当前正在处理的文件</p><p>-z    调用gzip进行压缩或解压缩</p><p>-j    调用bzip2进行压缩或解压缩</p><p>-J    调用xz进行压缩或解压缩</p></li><li><p><code>gzip</code>：压缩和解压gz后缀文件</p><p>-d    解压gzip压缩文件</p><p>-c    压缩或解压结果输出到STDOUT</p><p>-num  [1-9]    数字越小压缩比率越低，速度越快，<code>-1</code>等效于<code>-fast</code>，<code>-9</code>等效于<code>-best</code></p></li><li><p><code>unzip</code>：解压zip后缀文件</p></li><li><p><code>bzip2</code></p></li></ol><h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><ol><li><p><code>chmod</code>：修改文件读写执行等权限，只能修改属主为自己的文件或文件夹</p><p>4, r代表read权限，2, w代表write权限，1, x代表execution权限</p><p>eg: <code>chmod +x file</code>    添加文件执行权限</p><p>​      <code>chomd 755 file</code>    修改文件权限为属主读写执行，用户组读写，所有用户读写权限</p></li><li><p><code>chown</code>：修改文件属主信息，eg：<code>chown -R user:group file</code></p><p>-R    递归修改子文件、目录属主信息</p></li></ol><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><ol><li><p><code>grep</code>, <code>zgrep</code>：文件内容查找</p><p>-f  file    查找pattern在file中</p><p>-v    取反，显示不包含pattern的行</p><p>-c    计数，输出包含pattern的行数</p></li><li><p><code>find</code>：查找文件，指定文件路径下</p></li><li><p><code>locate</code>：查找文件，所有硬盘内</p></li><li><p><code>awk</code>：这个命令可以学，详细教程可参考<a href="https://github.com/mylxsw/growing-up/blob/master/doc/%E4%B8%89%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9AAWK.md" target="_blank" rel="noopener">https://github.com/mylxsw/growing-up/blob/master/doc/%E4%B8%89%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9AAWK.md</a></p></li><li><p><code>sed</code>：这个也可以学，详细教程可参考<a href="https://github.com/mylxsw/growing-up/blob/master/doc/%E4%B8%89%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9ASED.md" target="_blank" rel="noopener">https://github.com/mylxsw/growing-up/blob/master/doc/%E4%B8%89%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9ASED.md</a></p></li></ol><h1 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h1><ol><li><p><code>top</code>：显示进程</p><p>-c    显示详细命令</p><p>-u  user    显示特定user进程</p></li><li><p><code>ps</code></p></li><li><p><code>kill</code>： kill进程</p></li><li><p><code>free</code>：查看内存</p></li><li><p><code>history</code>：查看shell执行历史记录</p></li></ol><p>Linux系统命令可以通过<code>man command</code>或者<code>command --help</code>的方式查看详细帮助信息</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>parse pe fastq file use python</title>
      <link href="/2017/201703_parsePEfastq/"/>
      <url>/2017/201703_parsePEfastq/</url>
      <content type="html"><![CDATA[<p>github看了业界大神<a href="https://github.com/lh3" target="_blank" rel="noopener">li heng</a>序列解析的脚本readfq，智商着急啊，没看懂，倒是新学了一个新功能，<strong>python生成器<code>yield</code>。</strong></p><p><a href="https://github.com/lh3/readfq/blob/master/readfq.py" target="_blank" rel="noopener">readfq.py</a>适用于fasta或者单端fastq文件，但是目前测序主要以双端数据为主，现学现卖，实现了一个paried-end数据解析器，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># --*-- coding:utf-8 --*--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_pe_fastq</span><span class="params">(fastq1,fastq2,phred=<span class="number">33</span>)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> numpy <span class="keyword">import</span> fromstring,byte</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        name1 = fastq1.readline().partition(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line">        name2 = fastq2.readline().partition(<span class="string">' '</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name1 <span class="keyword">or</span> <span class="keyword">not</span> name2:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        read1, nothing1, qual1 = fq1.readline()[:<span class="number">-1</span>], fq1.readline(), fq1.readline()[:<span class="number">-1</span>]</span><br><span class="line">        read2, nothing2, qual2 = fq2.readline()[:<span class="number">-1</span>], fq2.readline(), fq2.readline()[:<span class="number">-1</span>]</span><br><span class="line">        qual1 = fromstring(qual1,dtype=byte)-phred</span><br><span class="line">        qual2 = fromstring(qual2,dtype=byte)-phred</span><br><span class="line">        <span class="keyword">assert</span> name1 == name2, <span class="string">'fastq1, fastq2 is not paired-end'</span></span><br><span class="line">        <span class="keyword">yield</span> name1, read1, read2, qual1, qual2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fq1 = gzip.open(sys.argv[<span class="number">1</span>],<span class="string">'r'</span>)</span><br><span class="line">    fq1 = gzip.open(sys.argv[<span class="number">2</span>],<span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> parse_pe_fastq(fq1, fq2):</span><br><span class="line">        name, seq1, seq2, qua1, qua2 = i</span><br><span class="line">        <span class="comment"># filter, stat, split</span></span><br></pre></td></tr></table></figure><p>通过<code>while</code>循环遍历双端文件，四行为一个单元进行数据读取，每四行作为一个完整单元返回（<code>yeild</code>），进行其他操作（<code># filter, stat, split</code>）， 一个操作结束后迭代器（<code>parse_pe_fastq</code>）继续解析测序数据，for循环中qua1作为一个<code>numpy.ndarray</code>对象，可进行其他一些q20统计、过滤等操作。</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>&#39;XXX，从入门到放弃&#39;</title>
      <link href="/2017/201703_GettingStarted/"/>
      <url>/2017/201703_GettingStarted/</url>
      <content type="html"><![CDATA[<p>生物背景从事生物信息分析工作，本科时候对统计、计算机之类的有些兴趣，觉着“<strong>生物信息</strong>”很高大上的样子，什毛都不懂就如了生信的坑，这一路下来，知道越多越觉得需要了解、懂的东西也越多，经常有“<strong>我擦勒，要学这么多东西啊</strong>” ， <code>linux</code>, <code>R</code>, <code>python</code>, <code>perl</code>…… 微博上看了各种从入门到放弃系列，觉得很有意思，这里也不自知的写个从入门到放弃吧，生物信息是一个多学科的交叉学科，遗传、生理、计算机、统计基础好像都须知道一些，“<strong>XXX，从入门到放弃</strong>”，我也不知道是啥从入门到放弃。</p><p>很早就有利用博客整理、交流学习思路的想法，懒癌穷癌很成功的阻止了我，看到很多利用github的教程，简单粗暴，终于鼓起勇气试试。</p><p>讲真，统计不是很懂，遗传不知道怎么说起，那就说说生信分析的linux、R、python这些咯。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>分析主要工作环境，<strong>命令行</strong>操作，分析工具众多。</p><p>基础命令：cd，pwd，ls，mkdir，rm，touch，cp，mv，echo，wc，ln</p><p>文件查看：head，tail，more，less，cat (zcat)</p><p>打包压缩：tar，gzip，zip，bzip2</p><p>文件处理：vim，awk，sed，grep (zgrep)，join</p><p>其他几个有用的命令：find，top，ps，kill，free</p><p>Linux系统命令可以通过<code>man command</code>或者<code>command --help</code>的方式查看帮助信息</p><p><strong>其他几个须知的点</strong>：重定向<code>&gt;</code>，文本追加<code>&gt;&gt;</code>，管道<code>|</code>，后台运行<code>&amp;</code>和<code>nohup</code>，标准输入、标准输出和标准错误</p><h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><p>两个功能，分析和绘图。分析这个主要是利用一些现成R package，例如转录组分析中DESeq、edgeR这些；绘图，当时还是ggplot2，教程很多，我这个R战五渣没有发言权。学习R，当然要有<a href="https://www.rstudio.com/" target="_blank" rel="noopener">RStudio</a>，R书籍什么的， <a href="">R语言实战</a>、<a href="">ggplot2数据分析与图形艺术</a>都可以看下。</p><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><p>主要是文件整理吧，不同格式转换，提取有效信息。python语法简单，基本上很快都能写出实现自己功能的代码，有很多第三方modules帮你实现想要的功能，另外学习的人多啊，不怕找不到人问问题。</p><p>编程能力这个还是靠<strong>多练习</strong>了，一些知识点就只能自己看书看教程背，现在网上也很多python相关的资料教程，边看边练习，入门很快的。记得，我当时看了很多七七八八的教程，然而少练习，折腾挺长时间，廖雪峰的<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="noopener">python教程 (2.7)</a>，<a href="">笨方法学python</a> ，github上也是有很多python学习笔记或者英文书籍翻译。</p><p>强烈推荐<a href="http://ipython.org/" target="_blank" rel="noopener">ipython</a>，可以理解为python里的Rstudio吧，可以生成富文本(<strong>filename.ipynb</strong>)文件，很方便用于脚本展示、交流。</p><p><a href="https://www.continuum.io/" target="_blank" rel="noopener">Anaconda</a> ，一个python科学计算环境，包括了常用的numpy、pandas、matplotlib、ipython等modules，管理python工作环境，实现<code>python2</code>, <code>python3</code>和谐共存，这个也是刚开始了解，熟悉的朋友可以交流交流。</p><h1 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h1><p>和python类似吧，文件整理。这个这个，只会打印<code>hello, world</code>，算是不会了，网上也很多博客教程，可以参考学习。</p><hr><h1 id="其他技能"><a href="#其他技能" class="headerlink" title="其他技能"></a>其他技能</h1><h2 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h2><p>语法简单，结果展示酷炫，低门槛装逼利器。</p><p><a href="https://typora.io/" target="_blank" rel="noopener">Typore</a>：免费markdown编辑器里面最好的，界面简洁，支持多种格式（pdf，html，docx等等）导出。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>可以掌握的技能。关注<a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a>，这是因为同事提到工作流程迁移系统环境兼容的问题，docker完全免去了这些烦恼。无奈，工作系统版本太低，无法安装，还没有试过。</p>]]></content>
      
      <categories>
          
          <category> bioinfor </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
